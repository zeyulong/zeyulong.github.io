

<!DOCTYPE html>
<html lang="zh-CN" >



<head><!-- hexo injector head_begin start --><progress id="content_progress" value="0"></progress><!-- hexo injector head_begin end -->
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/theme/TamakoAvatar-new-zip.png">
  <link rel="icon" href="/img/theme/TamakoAvatar-new-zip.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#000000">
  <meta name="author" content="龙泽雨">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文主要分享了Git的配置与常用操作，方便日常进行版本管理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Git的配置与使用">
<meta property="og:url" content="http://zeyulong.com/posts/5b8fd703/index.html">
<meta property="og:site_name" content="龙泽雨的博客">
<meta property="og:description" content="本文主要分享了Git的配置与常用操作，方便日常进行版本管理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/Git%E6%B5%81%E7%A8%8B-1.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/Git%E6%B5%81%E7%A8%8B-2.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/GitFlow%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/Master%E5%92%8CDevelop%E5%88%86%E6%94%AF.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/Feature%E5%88%86%E6%94%AF.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/Release%E5%88%86%E6%94%AF.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/Hotfix%E5%88%86%E6%94%AF.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/feature_branch_diagram.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/feature_branch_diverge_from_master_diagram.png">
<meta property="og:image" content="http://zeyulong.com/posts/5b8fd703/rebase_result_diagram.png">
<meta property="article:published_time" content="2024-05-09T03:34:55.000Z">
<meta property="article:modified_time" content="2025-06-03T14:56:06.952Z">
<meta property="article:author" content="龙泽雨">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://zeyulong.com/posts/5b8fd703/Git%E6%B5%81%E7%A8%8B-1.png">
  
  
  
  <title>Git的配置与使用 - 龙泽雨的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/custom/Markdown/macpanel.css">
<link rel="stylesheet" href="/custom/Fonts/CodeFont.css">
<link rel="stylesheet" href="/custom/Fonts/inlinecode-bg-color.css">
<link rel="stylesheet" href="/custom/live2d/font-awesome.min.css">
<link rel="stylesheet" href="/custom/LoadingBar/pace-theme-corner-indicator.css">
<link rel="stylesheet" href="/custom/ReadingProgress/ReadingProgress.css">
<link rel="stylesheet" href="/custom/SelectBackgroundColor/SelectBackgroundColor.css">
<link rel="stylesheet" href="/custom/waline/gif.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zeyulong.com","root":"/","version":"1.9.7","typing":{"enable":false,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"8gUBTaCjmaSbnf4genwggan3-MdYXbMMI","app_key":"2WRxjgxRXIWRBo8EA4205Wfm","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<!-- hexo injector head_end start --><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200;300;400;500;600;700;900&display=swap" rel="stylesheet"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Happy every day!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-steam"></i>
                <span>摸鱼</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/2048" target="_self">
                    
                    <span>2048</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/bcbk/1" target="_self">
                    
                    <span>别踩白块-1</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/bcbk/2" target="_self">
                    
                    <span>别踩白块-2</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/dblk" target="_self">
                    
                    <span>躲避绿块</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/dr" target="_self">
                    
                    <span>恐龙快跑</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://mario-kart-3-js.vercel.app/" target="_self">
                    
                    <span>马里奥赛车</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/mf" target="_self">
                    
                    <span>魔方</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/cat" target="_self">
                    
                    <span>圈小猫</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/sl" target="_self">
                    
                    <span>扫雷</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/txz" target="_self">
                    
                    <span>推箱子</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/game/wzq" target="_self">
                    
                    <span>五子棋</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/theme/GirlWithCat-cut.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Git的配置与使用</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        龙泽雨
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-09 11:34" pubdate>
          2024年5月9日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          174 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Git的配置与使用</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年6月3日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>本文主要分享了Git的配置与常用操作，方便日常进行版本管理。</p>
<span id="more"></span>
<h1 id="安装与配置">安装与配置</h1>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/">Git官网</a></p>
<h2 id="安装Git">安装Git</h2>
<ul>
<li>
<p>Windows：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41521682/article/details/122764915">参考安装教程</a>（推荐查找此时最新的安装教程）</p>
</li>
<li>
<p>Linux：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo add-apt-repository ppa:git-core/ppa<br>sudo apt update<br>sudo apt install git<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Mac：<a target="_blank" rel="noopener" href="https://git-scm.com/download/mac">官方下载地址</a></p>
</li>
</ul>
<h2 id="配置Git">配置Git</h2>
<p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示当前的Git配置</span><br>git config --list  <span class="hljs-comment"># 在Linux系统按`q`键退出</span><br><br><span class="hljs-comment"># 编辑Git配置文件。全局：~/.gitconfig，项目：/yourfolder/.git/config</span><br>git config -e [--global]  <span class="hljs-comment"># 在Linux系统按 Ctrl+X 退出</span><br></code></pre></td></tr></table></figure>
<h3 id="编辑器">编辑器</h3>
<p>默认情况下，Git 会调用你通过环境变量 <code>$VISUAL</code> 或 <code>$EDITOR</code> 设置的文本编辑器， 如果没有设置，默认则会调用 <code>vi</code> 来创建和编辑你的提交以及标签信息。 你可以使用 <code>core.editor</code> 选项来修改默认的编辑器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor gedit  <span class="hljs-comment"># nano vim gedit notepad++ Code emacs</span><br></code></pre></td></tr></table></figure>
<p>现在，Git 会调用 gedit 编辑信息。</p>
<h3 id="用户信息">用户信息</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置提交代码时的用户信息</span><br><span class="hljs-comment"># 因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识</span><br>git config --global user.name <span class="hljs-string">&quot;name&quot;</span>  <span class="hljs-comment"># --global表示设置为全局可用，如果想设置局部可用，对某个仓库指定的不同的用户名和邮箱，删除global即可</span><br>git config --global user.email <span class="hljs-string">&quot;email address&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="网络代理">网络代理</h3>
<ol>
<li>
<p>配置了科学上网。首先确保浏览器能够访问谷歌，能访问<a target="_blank" rel="noopener" href="https://github.com">GitHub</a>。</p>
</li>
<li>
<p>查看命令窗口的git配置。git是否设置了代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --get http.proxy<br>git config --global --get https.proxy<br></code></pre></td></tr></table></figure>
<p>如果什么都没有显示，说明没有配置代理。</p>
</li>
<li>
<p>为git设置代理。在linux的设置，网络中查看代理的地址，例如设置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&#x27;127.0.0.1:1080&#x27;</span><br>git config --global https.proxy <span class="hljs-string">&#x27;127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>根据自己的端口号配置。</p>
</blockquote>
<p>这时候再次查看应该有代理内容输出，此时在git应该是可行的。</p>
</li>
<li>
<p>（可选）git移除代理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>大功告成。</p>
</li>
</ol>
<h3 id="ping测试">ping测试</h3>
<p>在终端测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping github.com<br></code></pre></td></tr></table></figure>
<p>如果请求超时，则，例如，在Windows下：</p>
<ol>
<li>
<p><a target="_blank" rel="noopener" href="https://www.ipaddress.com/">IP地址查询网站</a>。查询下列两个网站的IP并记录下来：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://github.com">github.com</a></li>
<li><a target="_blank" rel="noopener" href="http://github.global.ssl.fastly.net">github.global.ssl.fastly.net</a></li>
</ul>
<p>例如，得到：</p>
<ul>
<li>140.82.114.3</li>
<li>151.101.1.194</li>
</ul>
</li>
<li>
<p>使用文本编辑器打开<code>C:\Windows\System32\drivers\etc\</code>下的<code>host</code>文件，在最后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs host">140.82.114.3 github.com<br>151.101.1.194 github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure>
<p>保存。</p>
<blockquote>
<p>如果不能修改，右击<code>host</code>文件-属性-安全-编辑-权限：修改“√”-确定。</p>
</blockquote>
</li>
<li>
<p>完成。</p>
</li>
</ol>
<h2 id="绑定GitHub账户">绑定GitHub账户</h2>
<ol>
<li>
<p>检验一下是否安装了SSH：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh<br><span class="hljs-comment"># 输出如下：</span><br>usage: ssh [-46AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]<br>           [-D [bind_address:]port] [-E log_file] [-e escape_char]<br>           [-F configfile] [-I pkcs11] [-i identity_file]<br>           [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec]<br>           [-O ctl_cmd] [-o option] [-p port] [-Q query_option] [-R address]<br>           [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]<br>           [user@]hostname [<span class="hljs-built_in">command</span>]<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>指定 RSA 算法生成密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa  <span class="hljs-comment"># 敲四次回车键，之后就就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>默认生成目录：</p>
<ul>
<li>Windows：<code>C:/Users/ASUS/.ssh</code></li>
<li>Linux：<code>~/.ssh</code></li>
<li>Mac：<code>~/.ssh</code></li>
</ul>
</blockquote>
</li>
<li>
<p>把公钥<code>id_rsa.pub</code>的内容添加到GitHub。</p>
<ol>
<li>
<p>复制<code>id_rsa.pub</code>文件内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit ~/.ssh/id_rsa.pub  <span class="hljs-comment"># 全选、复制</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>进入自己的GitHub主页，点击右上角头像，点击<code>Settings</code>，点击左栏<code>Access</code>-<code>SSH and GPG keys</code>，点击右上角<code>New SSH key</code>，将复制的公钥<code>id_rsa.pub</code>的内容粘贴到<code>key</code>内，<code>Title</code>内容自定义即可，点击<code>Add SSH key</code>。</p>
</li>
<li>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br><span class="hljs-comment"># -&gt; Are you sure you want to continue connecting (yes/no)?</span><br><span class="hljs-built_in">yes</span><br><span class="hljs-comment"># -&gt; Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>大功告成。</p>
</li>
</ol>
<h1 id="相关知识">相关知识</h1>
<h2 id="Git流程">Git流程</h2>
<img src="/posts/5b8fd703/Git%E6%B5%81%E7%A8%8B-1.png" srcset="/img/loading.gif" lazyload class="" title="Git流程-1">
<img src="/posts/5b8fd703/Git%E6%B5%81%E7%A8%8B-2.png" srcset="/img/loading.gif" lazyload class="" title="Git流程-2">
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h2 id="工作区与暂存区的区别">工作区与暂存区的区别</h2>
<ul>
<li>工作区：就是你在电脑上看到的目录，比如目录里的文件(<code>.git</code>隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li>
<li>版本库(Repository)：工作区有一个隐藏目录<code>.git</code>,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</li>
</ul>
<p>使用Git提交文件到版本库有两步：</p>
<ol>
<li>使用<code>git add</code>把文件添加进去，实际上就是把文件添加到暂存区。</li>
<li>使用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</li>
<li>（可选）使用<code>git push</code>将本地仓库的内容push到远程仓库。</li>
</ol>
<h2 id="文件状态">文件状态</h2>
<p>Git库所在的文件夹中的文件状态：</p>
<ul>
<li><code>untracked</code>：未跟踪。这些是在工作目录中创建的，但还没有被暂存（或用<code>git add</code>命令添加）的任何新文件或目录。</li>
<li><code>unmodify</code>：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，而变为<code>modified</code>。如果使用<code>git rm</code>移出版本库，则成为<code>untracked</code>文件。</li>
<li><code>modified</code>：文件已修改，仅仅是修改，并没有进行其他的操作。这个文件也有两个去处，通过<code>git add</code>可进入暂存<code>staged</code>状态，使用<code>git checkout</code>则丢弃修改过，返回到<code>unmodify</code>状态，这个<code>git checkout</code>即从库中取出文件，覆盖当前修改。</li>
<li><code>staged</code>：暂存状态。执行<code>git commit</code>则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为<code>unmodify</code>状态。执行<code>git reset HEAD filename</code>取消暂存，文件状态为<code>modified</code>。</li>
<li><code>tracked</code>：这些是Git所知道的所有文件或目录。这些是新添加（用<code>git add</code>添加）和提交（用<code>git commit</code>提交）到主仓库的文件和目录。</li>
<li><code>ignored</code>：这些是Git知道的要全部排除、忽略或在Git仓库中不需要注意的所有文件或目录。本质上，这是一种告诉Git哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法。</li>
</ul>
<p>Git 状态<code>untracked</code>和<code>not staged</code>的区别：</p>
<ul>
<li><code>untrack</code>：表示是新文件，没有被<code>git add</code>过，是为跟踪的意思。</li>
<li><code>not staged</code>：表示<code>git add</code>过的文件，即跟踪文件。再次修改还没有进行<code>git add</code>，就是没有暂存的意思。</li>
</ul>
<h2 id="git文件夹的构成">.git文件夹的构成</h2>
<ol>
<li><strong>config</strong> 文件：这个文件包含了项目级别的配置选项。这里的配置仅适用于当前仓库。可以通过 <code>git config</code> 命令查看或修改这些配置。</li>
<li><strong>description</strong> 文件：这个文件仅用于 GitWeb 程序描述仓库，通常不需要修改。</li>
<li><strong>HEAD</strong> 文件：这个文件指向当前仓库中被检出的分支。通常此文件包含一个引用到 <code>refs/heads</code> 目录中的分支。</li>
<li><strong>hooks/</strong> 目录：这个目录包含客户端或服务端的钩子脚本（hooks），这些脚本在特定的重要动作发生时触发。</li>
<li><strong>index</strong> 文件：该文件保存了暂存区的信息，即当前已经 git add 但还没有提交的变更。</li>
<li><strong>info/</strong> 目录：包含一个 <code>exclude</code> 文件，用于定义不需要通过 <code>.gitignore</code> 文件公开排除的文件的局部模式（通常用于仅在当前仓库中忽略某些文件或目录）。</li>
<li><strong>logs/</strong> 目录：存储了所有的引用（分支）的变更历史，每次提交或引用更新时都会记录在该目录下。</li>
<li><strong>objects/</strong> 目录：这是 Git 存放所有数据（如提交对象、树对象、二进制大对象即 blob 等）的地方。
<ol>
<li>在 <code>objects/</code> 文件夹中，对象通过其 SHA-1 哈希的前两个字符来组织为子目录，剩下的 38 个字符作为子目录中的文件名。例如，一个 SHA-1 哈希值为 <code>de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3</code> 的对象会存储在 <code>objects/de/9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3</code>。当 Git 需要查找一个对象时，它首先会计算对象名称的 SHA-1 哈希值，然后先查找前两个字符对应的目录，再在该目录中查找剩余 38 字符命名的文件。这种方法有助于快速定位和访问存储对象。</li>
<li><code>info</code> 文件夹下通常包含一个名为 <code>packs</code> 的文件，它记录了所有的包文件（pack files）的索引，使得 Git 可以快速地定位并验证 pack 文件中的对象。</li>
<li><code>pack</code> 文件夹存放了 Git 的 pack 文件，这些文件是 Git 用来存储对象库中对象的压缩格式，尤其是在仓库较大或有大量历史提交时使用。
<ol>
<li><strong>.pack 文件</strong>：这些是实际的包文件，包含了多个压缩的 Git 对象。一个 pack 文件通常包含了一个项目的多个版本的文件和目录。</li>
<li><strong>.idx 文件</strong>：每个 <code>.pack</code> 文件都有一个对应的 <code>.idx</code> 索引文件。索引文件包含了所有包内对象的索引，使得 Git 可以快速找到任何特定对象所在的位置。<code>.idx</code> 文件通过二分查找等算法优化了访问速度。</li>
</ol>
</li>
</ol>
</li>
<li><strong>refs/</strong> 目录：包含对本地分支（在 <code>refs/heads/</code> 中）、远程仓库的引用（在 <code>refs/remotes/</code> 中）和标签（在 <code>refs/tags/</code> 中）的指针。每个文件都包含一个 SHA-1 哈希值，指向 Git 数据库中的对象。</li>
</ol>
<h1 id="拉取与推送">拉取与推送</h1>
<h2 id="基本语法">基本语法</h2>
<h3 id="初始化init">初始化init</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init  <span class="hljs-comment"># 建立一个标准的Git仓库。这样的仓库初始化后，其项目目录为工作空间，其下的.git目录是版本控制器。</span><br><br>git init --bare  <span class="hljs-comment"># 建立一个“裸”的Git仓库。一般用来初始化远程服务器仓库。</span><br><span class="hljs-comment"># 这样的仓库初始化后，其项目目录下就是标准仓库.git目录里的内容，没有工作空间。这个仓库只保存git历史提交的版本信息，而不允许用户在上面进行各种git操作（如：push、commit操作）。但是，你依旧可以使用git show命令查看提交内容。</span><br><span class="hljs-comment"># 不能进行checkout切换分支的操作，提示为`fatal: this operation must be run in a work tree`</span><br><span class="hljs-comment"># 可以通过pull或clone在其它位置获得原仓库的完整内容</span><br></code></pre></td></tr></table></figure>
<h3 id="拉取pull">拉取pull</h3>
<p><code>git pull</code>命令用于从远程获取代码并合并本地的版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>git pull origin master:brantest  <span class="hljs-comment"># 将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并</span><br><span class="hljs-comment"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略</span><br>git pull origin master<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果当前分支和要合并的分支存在冲突，Git会要求我们解决冲突并手动执行合并操作。</p>
</blockquote>
<h3 id="推送push">推送push</h3>
<p><code>git push</code>命令用于从将本地的分支版本上传到远程并合并。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br><span class="hljs-comment"># 如果本地分支名与远程分支名相同，则可以省略冒号：</span><br>git push &lt;远程主机名&gt; &lt;本地分支名&gt;<br>git push origin master  <span class="hljs-comment"># 将本地的 master 分支推送到 origin 主机的 master 分支，相当于：</span><br>git push origin master:master<br><span class="hljs-comment"># 如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：</span><br>git push --force origin master<br>git push [remote] --all  <span class="hljs-comment"># 推送所有分支到远程仓库</span><br></code></pre></td></tr></table></figure>
<h3 id="克隆clone">克隆clone</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [url]  <span class="hljs-comment"># [url] 是你要拷贝的项目</span><br><span class="hljs-comment"># 执行完上述步骤后，Git 会克隆远程仓库到本地，并在当前目录下创建一个与远程仓库同名的文件夹</span><br><span class="hljs-comment"># 上述操作将复制该项目的全部记录</span><br><br>git <span class="hljs-built_in">clone</span> &lt;repository-url&gt; &lt;local-directory&gt;<br><span class="hljs-comment"># &lt;repository-url&gt; 是你想克隆的远程 Git 仓库的 URL</span><br><span class="hljs-comment"># &lt;local-directory&gt; 是你想创建本地副本的目录路径</span><br><br><span class="hljs-comment"># 克隆特定分支</span><br>git <span class="hljs-built_in">clone</span> --branch my-branch https://github.com/my-username/my-repository.git<br><span class="hljs-comment"># 克隆特定标签</span><br>git <span class="hljs-built_in">clone</span> --branch v1.0.0 https://github.com/my-username/my-repository.git<br><span class="hljs-comment"># 克隆特定提交</span><br>git <span class="hljs-built_in">clone</span> --branch 4c4ba1d https://github.com/my-username/my-repository.git<br><span class="hljs-comment"># 克隆子目录</span><br>git <span class="hljs-built_in">clone</span> --depth 1 --filter=blob:none https://github.com/my-username/my-repository.git my-subdirectory  <span class="hljs-comment"># 这个命令将创建 my-repository 仓库的 my-subdirectory 子目录中的文件的本地副本</span><br><span class="hljs-comment"># depth 用于指定克隆深度，为1即表示只克隆最近一次commit</span><br><br>git <span class="hljs-built_in">clone</span> --bare &lt;url&gt; [&lt;directory&gt;]  <span class="hljs-comment"># 它将克隆一个裸仓库（bare repository）。裸仓库是一个没有工作目录的Git仓库，只包含版本对象和引用，不保存源代码的修改历史，非常适合用作中央仓库或备份</span><br>git <span class="hljs-built_in">clone</span> --bare https://github.com/username/repository.git<br><br>git <span class="hljs-built_in">clone</span> --recursive &lt;repository_url&gt;  <span class="hljs-comment"># 我们在一个项目中使用了开源库或第三方库，而这些库通常会作为子模块嵌入到我们的项目中。如果我们使用普通的 Git Clone 命令只会将主项目克隆下来，而不会将子模块一同克隆。这时候，我们就可以使用 Git Clone –recursive 来克隆主项目和子模块。</span><br><span class="hljs-comment"># if you forgot the `--recursive` options, you can run below git commands after cloning:</span><br><span class="hljs-comment">#   git submodule sync --recursive</span><br><span class="hljs-comment">#   git submodule update --init --recursive --force</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果父仓库中包含子 Git 仓库（即独立的 Git 仓库目录，并且每个子目录中有自己的 <code>.git</code> 文件夹），执行 <code>git clone</code> 时，Git 会将这些子仓库当作普通文件夹处理，直接复制它们的内容，包括 <code>.git</code> 文件夹。</p>
</blockquote>
<h3 id="增加add-删除rm-移动mv文件">增加add/删除rm/移动mv文件</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add [file1] [file2] ...  <span class="hljs-comment"># 添加指定文件到暂存区</span><br>git add [<span class="hljs-built_in">dir</span>]  <span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span><br>git add .  <span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br><br><span class="hljs-comment"># 添加每个变化前，都会要求确认</span><br><span class="hljs-comment"># 对于同一个文件的多处变化，可以实现分次提交</span><br>git add -p<br><br>git <span class="hljs-built_in">rm</span> [file1] [file2] ...  <span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span><br>git <span class="hljs-built_in">rm</span> --cached [file]  <span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区</span><br>git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]  <span class="hljs-comment"># 改名文件，并且将这个改名放入暂存区</span><br></code></pre></td></tr></table></figure>
<h3 id="提交commit">提交commit</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m [message]  <span class="hljs-comment"># 提交暂存区到仓库区</span><br><span class="hljs-comment"># 如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行</span><br><span class="hljs-comment"># 按Esc键，之后I表示插入模式。输入一个你想要的提交信息。在:wq之后按Esc键，保存并退出编辑器。这样，我们就成功地进行了一次提交。</span><br>git commit [file1] [file2] ... -m [message]  <span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br>git commit -a  <span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>git commit -v  <span class="hljs-comment"># 提交时显示所有diff信息</span><br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>git commit --amend -m [message]<br><br>git commit --amend [file1] [file2] ...  <span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>git commit -m</code> 提交的内容换行：</p>
<ul>
<li>
<p>方法1：先输入第一个双引号，按<code>Enter</code>即可换行，完成后再补齐后面的双引号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;This is the first line.</span><br><span class="hljs-string">[Enter]</span><br><span class="hljs-string">This is the second line.&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>方法2：在双引号中使用转义字符<code>\n</code>来表示换行符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;This is the first line.\nThis is the second line.&quot;</span>  <span class="hljs-comment"># 转义字符\n只能在双引号中使用，单引号中的\n会被直接作为普通文本处理。</span><br><span class="hljs-comment"># 根据操作系统的不同，转义字符的使用可能会有所差异。在Windows系统下，您可能需要使用’^’符号来表示转义字符。</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>方法三：使用多个<code>-m</code>参数来提交多行的信息，每个<code>-m</code>参数代表一行提交信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;This is the first line.&quot;</span> -m <span class="hljs-string">&quot;This is the second line.&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>方法4：使用文件。</p>
<p>首先，创建一个名为<code>message.txt</code>的文本文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt+">This is the first line.<br>This is the second line.<br></code></pre></td></tr></table></figure>
<p>然后，可以使用以下命令来提交代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -F message.txt  <span class="hljs-comment"># 文件路径必须是相对于当前Git仓库根目录的路径</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h3 id="查看信息status-log-show">查看信息status/log/show</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status  <span class="hljs-comment"># 显示有变更的文件</span><br>git <span class="hljs-built_in">log</span>  <span class="hljs-comment"># 显示当前分支的版本历史</span><br>git <span class="hljs-built_in">log</span> --graph --pretty=format:<span class="hljs-string">&#x27;%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit --<span class="hljs-built_in">date</span>=relative  <span class="hljs-comment"># 更清晰的日志展示</span><br>git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span>  <span class="hljs-comment"># 显示commit历史，以及每次commit发生变更的文件</span><br>git <span class="hljs-built_in">log</span> -S [keyword]  <span class="hljs-comment"># 搜索提交历史，根据关键词</span><br>git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s  <span class="hljs-comment"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature  <span class="hljs-comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><br><span class="hljs-comment"># 显示某个文件的版本历史，包括文件改名</span><br>git <span class="hljs-built_in">log</span> --follow [file]<br>git whatchanged [file]<br><br>git <span class="hljs-built_in">log</span> -p [file]  <span class="hljs-comment"># 显示指定文件相关的每一次diff</span><br>git <span class="hljs-built_in">log</span> -5 --pretty --oneline  <span class="hljs-comment"># 显示过去5次提交</span><br><br>git shortlog -sn  <span class="hljs-comment"># 显示所有提交过的用户，按提交次数排序</span><br>git blame [file]  <span class="hljs-comment"># 显示指定文件是什么人在什么时间修改过</span><br><br>git show [commit] <span class="hljs-comment"># 显示某次提交的元数据和内容变化</span><br>git show --name-only [commit]  <span class="hljs-comment"># 显示某次提交发生变化的文件</span><br>git show [commit]:[filename]  <span class="hljs-comment"># 显示某次提交时，某个文件的内容</span><br>git reflog  <span class="hljs-comment"># 显示当前分支的最近几次提交，还有分支切换历史</span><br></code></pre></td></tr></table></figure>
<h3 id="远程仓库remote">远程仓库remote</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote –v  <span class="hljs-comment"># 查看远程库的详细信息</span><br><span class="hljs-comment"># 示例输出</span><br>origin  https://github.com/username/repository.git (fetch)<br>origin  https://github.com/username/repository.git (push)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>origin</code> 是远程仓库的名字。</li>
<li>后面的 URL 是远程仓库的地址。</li>
<li><code>(fetch)</code> 表示用于拉取代码的地址。</li>
<li><code>(push)</code> 表示用于推送代码的地址。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看信息</span><br>git remote  <span class="hljs-comment"># 查看远程库的信息</span><br>git remote show [remote]  <span class="hljs-comment"># 显示某个远程仓库的信息</span><br>git fetch [remote]  <span class="hljs-comment"># 下载远程仓库的所有变动</span><br><br><span class="hljs-comment"># 创建</span><br>git remote add [shortname] [url]  <span class="hljs-comment"># 增加一个新的远程仓库，并命名。使用shortname指代url，方便输入和记忆</span><br><br><span class="hljs-comment"># 删除</span><br>git remote <span class="hljs-built_in">rm</span> [远程主机名称]  <span class="hljs-comment"># 删除此远程连接</span><br></code></pre></td></tr></table></figure>
<h2 id="本地创建Git仓库">本地创建Git仓库</h2>
<blockquote>
<p>在操作Git仓库的时候多使用<code>git status</code>命令，这能帮助我们实时了解仓库的状态，非常有用。</p>
</blockquote>
<blockquote>
<p>在我们向远程仓库提交代码的时候，一定要先进行<code>pull</code>操作，再进行<code>push</code>操作，防止本地仓库与远程仓库不同步导致冲突的问题，尤其是<a href="#%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BAGit%E4%BB%93%E5%BA%93">本地创建Git仓库</a>的情况，很容易就出现问题。</p>
</blockquote>
<ol>
<li>
<p>建立一个本地仓库进入，init初始化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> yourfolder  <span class="hljs-comment"># 先进入到Git仓库的最顶层目录下</span><br>git init  <span class="hljs-comment"># 初始化仓库</span><br><span class="hljs-comment"># Initialized empty Git repository in ~/yourfolder/.git/</span><br></code></pre></td></tr></table></figure>
<p>这时候你当前的目录下会多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本的。</p>
</li>
<li>
<p>关联远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://github.com/raulmur/ORB_SLAM2.git  <span class="hljs-comment"># 关联远程仓库，同时将远程仓库命名为 origin</span><br></code></pre></td></tr></table></figure>
<p><a href="#%E5%B0%86%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95">将远程仓库设置为本地目录</a></p>
</li>
<li>
<p>（略）同步远程仓库和本地仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 带上 -u 参数其实就相当于记录了push到远端分支的默认值，这样当下次我们还想要继续push的这个远端分支的时候推送命令就可以简写成git push即可</span><br><span class="hljs-comment"># git pull origin master  # 将远程仓库origin的master分支的内容拉取到本地，与本地的master分支进行合并</span><br><span class="hljs-comment"># git push -u origin master  # 将本地的 master 分支推送到 origin 主机的 master 分支</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>接下来的步骤与<a href="#%E6%9C%AC%E5%9C%B0%E6%8B%89%E5%8F%96Git%E4%BB%93%E5%BA%93">本地拉取Git仓库</a>相同。先输入<code>git add</code>和<code>git commit</code>命令，将要提交的文件添加并提交到本地仓库；然后再输入<code>git push origin master</code>命令，将本地仓库修改（或者添加）的内容提交到远程仓库就完成啦。</p>
</li>
</ol>
<h2 id="本地拉取Git仓库">本地拉取Git仓库</h2>
<p>本地没有Git仓库，这时我们就可以直接将远程仓库<code>clone</code>到本地。通过<code>clone</code>命令创建的本地仓库，其本身就是一个 Git 仓库了，不用我们再进行<code>init</code>初始化操作啦，而且自动关联远程仓库。我们只需要在这个仓库进行修改或者添加等操作，然后<code>commit</code>即可。</p>
<ol>
<li>
<p>直接将远程仓库 clone 到本地；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> yourfolder/<br>git <span class="hljs-built_in">clone</span> https://github.com/raulmur/ORB_SLAM2.git<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>新建或修改文件。</p>
</li>
<li>
<p>将文件添加并commit到本地仓库：</p>
<p><a href="#%E6%8F%90%E4%BA%A4%E6%97%B6%E6%8C%87%E5%AE%9A%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%88%E5%A4%B9%EF%BC%89">提交时指定忽略的文件（夹）</a></p>
<p><a href="#%E8%A7%84%E8%8C%83%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF">规范提交信息</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> yourfolder/<br>git status  <span class="hljs-comment"># 查看仓库状态</span><br><span class="hljs-comment"># nothing added to commit but untracked files present (use &quot;git add&quot;to track)</span><br><br>git add . <span class="hljs-comment"># 将文件添加到了临时缓冲区</span><br>git commit -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 添加提交信息，可使用中文。见下文：规范提交信息</span><br><br><span class="hljs-comment"># 如果你是第一次提交的话，会让你输入用户名和邮箱：</span><br>git config --global user.email<span class="hljs-string">&quot;you@example.com&quot;</span>  <span class="hljs-comment"># --global表示设置为全局可用，如果想设置局部可用，对某个仓库指定的不同的用户名和邮箱，删除global即可</span><br>git config --global user.name<span class="hljs-string">&quot;Your Name&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>查看仓库提交日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br>git <span class="hljs-built_in">log</span> --graph --pretty=format:<span class="hljs-string">&#x27;%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27;</span> --abbrev-commit --<span class="hljs-built_in">date</span>=relative  <span class="hljs-comment"># 更清晰的日志展示</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>查看仓库状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br><span class="hljs-comment"># nothing to commit,working tree clean</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>将本地仓库的内容push到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master  <span class="hljs-comment"># 将本地仓库的内容提交到远程仓库，origin是远程主机的名字，master仓库的分支名</span><br><span class="hljs-comment"># 我们习惯性将远程仓库命名为origin，不过在需要关联多个远程仓库的时候，就需要我们再取别的名字啦！</span><br><span class="hljs-comment"># git push origin main</span><br><span class="hljs-comment"># git push -u origin main  # 带上 -u 参数其实就相当于记录了push到远端分支的默认值，这样当下次我们还想要继续push的这个远端分支的时候推送命令就可以简写成git push即可</span><br><br><span class="hljs-comment"># 第一次上传需要输入密码</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>大功告成。</p>
</li>
</ol>
<h2 id="规范提交信息">规范提交信息</h2>
<h3 id="一般步骤和规范">一般步骤和规范</h3>
<p><a href="#%E6%8F%90%E4%BA%A4">提交的内容实现换行</a></p>
<p>以下是一些撰写规范化提交信息的指导原则和建议步骤：</p>
<ol>
<li>
<p>使用清晰的语言。提交信息应该直接且简洁地描述所做的更改。使用简洁的语言有助于其他团队成员快速理解提交的目的。</p>
</li>
<li>
<p>遵循通用格式。一个广泛接受的<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular规范</a>格式是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;<span class="hljs-built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure>
<p>各部分说明如下：</p>
<ul>
<li>
<p><strong>type</strong>：提交类型:</p>
<ul>
<li><code>feat</code>：新功能（Feature）。<code>feat</code>用于表示引入新功能或特性的变动。这种变动通常是在代码库中新增的功能，而不仅仅是修复错误或进行代码重构。</li>
<li><code>fix/to</code>：修复bug。这些bug可能由QA团队发现，或由开发人员在开发过程中识别。
<ul>
<li><code>fix</code>关键字用于那些直接解决问题的提交。当创建一个包含必要更改的提交，并且这些更改能够直接修复已识别的bug时，应使用<code>fix</code>。这表明提交的代码引入了解决方案，并且问题已被立即解决。</li>
<li><code>to</code>关键字则用于那些部分处理问题的提交。在一些复杂的修复过程中，可能需要多个步骤或多次提交来完全解决问题。在这种情况下，初始和中间的提交应使用<code>to</code>标记，表示它们为最终解决方案做出了贡献，但并未完全解决问题。最终解决问题的提交应使用<code>fix</code>标记，以表明问题已被彻底修复。</li>
</ul>
</li>
<li><code>docs</code>：文档（Documentation）。<code>docs</code>表示对文档的变动，这包括对代码库中的注释、README文件或其他文档的修改。这个前缀的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8F%90%E4%BA%A4&amp;spm=1001.2101.3001.7020">提交</a>通常用于更新文档以反映代码的变更，或者提供更好的代码理解和使用说明。</li>
<li><code>style</code>: 格式（Format）。<code>style</code>用于表示对代码格式的变动，这些变动不影响代码的运行。通常包括空格、缩进、换行等风格调整。</li>
<li><code>refactor</code>：重构（即不是新增功能，也不是修改bug的代码变动）。<code>refactor</code>表示对代码的重构，即修改代码的结构和实现方式，但不影响其外部行为。重构的目的是改进代码的可读性、可维护性和性能，而不是引入新功能或修复错误。</li>
<li><code>perf</code>: 优化相关，比如提升性能、体验。<code>perf</code>表示与性能优化相关的变动。这可能包括对算法、数据结构或代码实现的修改，以提高代码的执行效率和用户体验。</li>
<li><code>test</code>：增加测试。<code>test</code>表示增加测试，包括单元测试、集成测试或其他类型的测试。</li>
<li><code>chore</code>：构建过程或辅助工具的变动。<code>chore</code>表示对构建过程或辅助工具的变动。这可能包括更新构建脚本、配置文件或其他与构建和工具相关的内容。</li>
<li><code>revert</code>：回滚到上一个版本。<code>revert</code>用于回滚到以前的版本，撤销之前的提交。</li>
<li><code>merge</code>：代码合并。<code>merge</code>表示进行代码合并，通常是在分支开发完成后将代码合并回主线。</li>
<li><code>sync</code>：同步主线或分支的Bug。<code>sync</code>表示同步主线或分支的 Bug，通常用于解决因为合并而引入的问题。</li>
</ul>
</li>
<li>
<p><strong>scope</strong>：用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。可选。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">feat(Controller): 添加用户登录功能<br><span class="hljs-comment"># 这个提交消息中，Controller 是 scope，表示这次提交影响了控制层。</span><br></code></pre></td></tr></table></figure>
<p>如果你的修改影响了不止一个scope，你可以使用<code>*</code>代替。</p>
</li>
<li>
<p><strong>subject</strong>：简短描述提交内容的标题，不超过50个字符。</p>
</li>
<li>
<p><strong>body</strong>：详细描述更改的内容，说明原因和与之前行为的对比，可以分成多行。可选。</p>
</li>
<li>
<p><strong>footer</strong>：Footer 部分只用于两种情况。可选。</p>
<ul>
<li>
<p>关联的 issue 或 pull request 号。</p>
</li>
<li>
<p>不兼容变动。如果当前代码与上一个版本不兼容，则 Footer 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">BREAKING CHANGE: isolate scope bindings definition has changed.<br><br>    To migrate the code follow the example below:<br><br>    Before:<br><br>    scope: &#123;<br>      myAttr: <span class="hljs-string">&#x27;attribute&#x27;</span>,<br>    &#125;<br><br>    After:<br><br>    scope: &#123;<br>      myAttr: <span class="hljs-string">&#x27;@&#x27;</span>,<br>    &#125;<br><br>    The removed `inject` wasn<span class="hljs-string">&#x27;t generaly useful for directives so there should be no code using it.</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用命令式语气。始终使用命令式的语气：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;fix bug causing system crash&quot;</span><br><span class="hljs-comment"># 而非</span><br>git commit -m <span class="hljs-string">&quot;fixed bug causing system crash&quot;</span><br>git commit -m <span class="hljs-string">&quot;fixes bug causing system crash&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>首字母小写。提交信息的标题建议首字母小写。</p>
</li>
<li>
<p>不要在标题行结束时加标点。标题应该简洁，在末尾没有标点结束。</p>
</li>
<li>
<p>分离标题与正文。标题行之后应该有一个空行，隔开标题和正文，有助于 Git 正确地格式化提交信息。</p>
</li>
<li>
<p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">revert: feat(pencil): add <span class="hljs-string">&#x27;graphiteWidth&#x27;</span> option<br><br>This reverts commit 667ecc1654a317a13331b17617d973392f415f02.<br></code></pre></td></tr></table></figure>
<p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p>
</li>
<li></li>
</ol>
<h3 id="举例">举例</h3>
<ol>
<li>
<p>添加新功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;feat: add user authentication system</span><br><span class="hljs-string"></span><br><span class="hljs-string">Implemented basic user authentication system using JWTs. This includes routes for registration, login, and token verification. The new system improves security by ensuring all actions require a valid token.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Resolves #123</span><br><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>修复一个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;fix: correct typo in API documentation</span><br><span class="hljs-string"></span><br><span class="hljs-string">The JSON request body example in the user creation endpoint documentation had a typo in the &#x27;email&#x27; field which has been corrected. This typo has potentially led to misunderstandings of API usage.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Spotted by @username in code review.</span><br><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>做出改进（重构）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;refactor: streamline user data handling</span><br><span class="hljs-string"></span><br><span class="hljs-string">Refactored the user data management to reduce redundancy and improve code clarity. Removed duplicated functions and replaced them with single setUser function that handles all scenarios.</span><br><span class="hljs-string"></span><br><span class="hljs-string">See merge request !456</span><br><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>文档更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;docs: update README with API endpoint changes</span><br><span class="hljs-string"></span><br><span class="hljs-string">Updated the README document to reflect recent changes in API endpoints. Added documentation for the newly introduced payment processing API.</span><br><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>添加用户配置文件编辑功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">feat(UserProfile): add user profile editing feature<br><br>This commit introduces a new feature that allows <span class="hljs-built_in">users</span> to edit their profiles<br>directly from the user interface. The motivation behind this change is to<br>enhance user interaction and provide a more seamless experience.<br><br>Previously, <span class="hljs-built_in">users</span> had to navigate to a separate editing page to update their<br>profile information. With this new feature, <span class="hljs-built_in">users</span> can now make changes<br>efficiently from their profile page, eliminating unnecessary steps <span class="hljs-keyword">in</span> the<br>workflow.<br><br>Changes included <span class="hljs-keyword">in</span> this commit:<br>- Added a new <span class="hljs-string">&#x27;Edit Profile&#x27;</span> button on the user profile page.<br>- Implemented frontend components <span class="hljs-keyword">for</span> profile editing.<br>- Updated backend API to handle profile updates securely.<br><br>By streamlining the profile editing process, we aim to improve overall user<br>satisfaction and make our application more user-friendly. This enhancement is<br><span class="hljs-keyword">in</span> response to user feedback, addressing the need <span class="hljs-keyword">for</span> a more intuitive and<br>accessible way to modify profile details.<br><br>Closes <span class="hljs-comment">#234</span><br></code></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h3 id="设置git-commit模板（不推荐）">设置<code>git commit</code>模板（不推荐）</h3>
<ol>
<li>
<p>建立模板文件。在项目中建立<code>.git_template</code>文件，内容可以自定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span>:<br>scope:<br>subject:<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>设置模板。运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config [--global] commit.template .git_template <span class="hljs-comment"># 当前项目。全局设置：可选参数 --global</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>提交代码。先使用<code>git add .</code>添加代码，然后使用<code>git commit</code>按照模板填写，最后<code>git push</code>推送到远端。</p>
</li>
</ol>
<blockquote>
<p>优点：规则可配置，更自由；配置方式简洁（只需添加配置文件）。</p>
<p>缺点：便利性差，每次都要使用编辑器填写模板；易出错，没有可靠的校验方式。</p>
</blockquote>
<h3 id="插件（推荐）">插件（推荐）</h3>
<h4 id="Commitizen">Commitizen</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/commitizen/cz-cli">Commitizen</a>是一个撰写合格 Commit message 的工具。安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g commitizen<br></code></pre></td></tr></table></figure>
<p>然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">commitizen init cz-conventional-changelog --save --save-exact<br></code></pre></td></tr></table></figure>
<p>以后，凡是用到<code>git commit</code>命令，一律改为使用<code>git cz</code>。这时，就会出现选项，用来生成符合格式的 Commit message。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git cz<br><br>git <span class="hljs-built_in">log</span>  <span class="hljs-comment"># 查看提交的 commit message</span><br></code></pre></td></tr></table></figure>
<h4 id="commitlint">commitlint</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint">commitlint</a>是一个用于检查提交消息是否符合指定规范的工具。它可以帮助团队确保 Git 提交消息的一致性和规范性，尤其是当项目采用类似 Angular Commit Message Conventions 的规范时。</p>
<ol>
<li>
<p>安装 Commitlint。首先，你需要安装 <code>commitlint</code> 及其相关的配置和规则。通常，<code>@commitlint/config-conventional</code> 是与 Angular 规范兼容的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev @commitlint/config-conventional @commitlint/cli<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>配置 Commitlint。在项目根目录下创建 <code>commitlint.config.js</code> 文件，并添加如下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>],<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这个配置文件使用了 <code>@commitlint/config-conventional</code> 中预定义的规则，确保符合常见的提交规范。</p>
<blockquote>
<p>检测规则有很多类，最常用的是上面采用的<a target="_blank" rel="noopener" href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits specification</a>。此规则是根据上文所说的Angular Team Commit Specification衍生出来的。commitlint更多规则可看：<code>Shared configuration</code>。</p>
<p>上面网址的规则中有两个比较类似的规则：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint/tree/master/@commitlint/config-angular">@commitlint/config-angular</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/conventional-changelog/commitlint/tree/master/@commitlint/config-conventional">@commitlint/config-conventional</a></li>
</ul>
<p><code>@commitlint/config-angular</code>是几乎满足了本文第二点中介绍的header、body、footer中所有的规则。然后添加了header中的type和scope必须为小写的规则。</p>
<p>而<code>@commitlint/config-conventional</code>是继承<code>@commitlint/config-angular</code>的全部规则上还有一些小的约束，例如</p>
<ul>
<li>header最大长度为100个字符</li>
<li>body和footer每行的最大长度为100个字符，注意这里是每行，即可以换行。</li>
</ul>
</blockquote>
</li>
<li>
<p>配置Git Hooks。你可以使用 Husky 钩子工具来在提交前运行 <code>commitlint</code>。首先，安装 Husky：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev husky<br></code></pre></td></tr></table></figure>
<p>然后，在 <code>package.json</code> 中添加以下配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;husky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;hooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;commit-msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>上述代码目的是为了在git执行commit和merge之前，先执行<code>commitlint -E HUSKY_GIT_PARAMS</code>。从而使<code>commitlint</code>检测提交信息。</p>
<blockquote>
<p>git hooks有很多个周期函数，更多可点击查看<a target="_blank" rel="noopener" href="https://git-scm.com/docs/githooks">githooks</a>。<code>pre-commit</code>和<code>pre-commit-msg</code>都是在因<code>git commit</code>触发的，而<code>commit-msg</code>是因<code>git commit</code>和<code>git merge</code>触发的，在多人合作项目中避免不了<code>git merge</code>指令，因此我们选择<code>commit-msg</code>周期函数。</p>
</blockquote>
</li>
<li>
<p>添加了以上两个配置后，每次<code>git commit</code>前就会根据规则检查。如果不符合规则，则会中断。</p>
</li>
</ol>
<h4 id="validate-commit-msg">validate-commit-msg</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/kentcdodds/validate-commit-msg">validate-commit-msg</a> 用于检查 Node 项目的 Commit message 是否符合格式。</p>
<p>它的安装是手动的。首先，拷贝下面这个<a target="_blank" rel="noopener" href="https://github.com/kentcdodds/validate-commit-msg/blob/master/index.js">JS文件</a>，放入你的代码库。文件名可以取为<code>validate-commit-msg.js</code>。</p>
<p>接着，把这个脚本加入 Git 的 hook。下面是在<code>package.json</code>里面使用 <a target="_blank" rel="noopener" href="http://npm.im/ghooks">ghooks</a>，把这个脚本加为<code>commit-msg</code>时运行：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ghooks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;commit-msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./validate-commit-msg.js&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>然后，每次<code>git commit</code>的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add -A <br>git commit -m <span class="hljs-string">&quot;edit markdown&quot;</span> <br><span class="hljs-comment"># INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! was: edit markdown</span><br></code></pre></td></tr></table></figure>
<h4 id="VS-Code">VS Code</h4>
<ul>
<li>Commit Message Editor</li>
<li>git-commit-plugin</li>
</ul>
<h4 id="Clion">Clion</h4>
<ul>
<li>Git Commit Message Helper：标准化提交信息。设置-其它设置-GitCommitMessageHelper</li>
</ul>
<h2 id="提交时指定忽略的文件（夹）">提交时指定忽略的文件（夹）</h2>
<blockquote>
<p>在新增文件（夹）时，如果其中有想要忽略的文件（夹），最好先更新<code>.gitignore</code>文件，再新增。避免新增的文件被直接提交到缓冲区，就需要手动删除想要忽略的文件（夹）的缓存了。</p>
</blockquote>
<h3 id="基本方法">基本方法</h3>
<blockquote>
<p>一般来说每个Git项目中都需要一个<code>.gitignore</code>文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。实际项目中，很多文件都是不需要版本管理的，比如Python的<code>.pyc</code>文件和一些包含密码的配置文件等等。这个文件的内容是一些规则，Git会根据这些规则来判断是否将文件添加到版本控制中。</p>
</blockquote>
<blockquote>
<p>通常，一个<code>.gitignore</code>文件会被放在仓库的根目录下。根目录也被称为父目录和当前工作目录。根目录包含了组成项目的所有文件和其他文件夹。当然，你也可以把它放在版本库的任何文件夹中。你甚至可以有多个 <code>.gitignore</code> 文件。</p>
</blockquote>
<blockquote>
<p>被过滤掉的文件就不会出现在Git仓库中了。当然本地库中还有，只是push的时候不会上传。</p>
</blockquote>
<p><mark>方法一：</mark> 在Git项目中定义<code>.gitignore</code>文件。在项目的某个文件夹下定义名为<code>.gitignore</code>文件，在该文件中定义相应的忽略规则，来管理当前文件夹下的文件的Git提交行为。文件是可以提交到公有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。在<code>.gitingore</code>文件中，遵循相应的语法，在每一行指定一个忽略规则。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git"># 忽略规则<br>*.log  # 忽略所有的log后缀的文件<br>*.temp<br>/vendor<br></code></pre></td></tr></table></figure>
<p><a href="#%60.gitignore%60%E5%BF%BD%E7%95%A5%E8%A7%84%E5%88%99%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95">详细语法</a></p>
<p><mark>方法二：</mark> 在Git项目的设置中指定排除文件。这种方式只是临时指定该项目的行为，需要编辑当前项目下的<code>.git/info/exclude</code>文件，然后将需要忽略提交的文件写入其中。需要注意的是，这种方式指定的忽略文件的根目录是项目根目录。这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者。</p>
<p><mark>方法三：</mark> 定义Git全局的<code>.gitignore</code>文件。除了可以在项目中定义<code>.gitignore</code>文件外，还可以设置全局的<code>git .gitignore</code>文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。这种方式也需要创建相应的<code>.gitignore</code>文件，可以放在任意位置（比如：<code>/home/wangshibo/hqsb_ios</code>）。然后在当前目录下使用以下命令配置Git：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.excludesfile ~/.gitignore<br><span class="hljs-comment"># 你会发现在~/.gitconfig文件中会出现excludesfile = /home/wangshibo/hqsb_ios/.gitignore</span><br><span class="hljs-comment"># 说明Git把文件过滤规则应用到了Global的规则中</span><br></code></pre></td></tr></table></figure>
<h3 id="多-gitignore的优先级">多<code>.gitignore</code>的优先级</h3>
<p>在Git中，通配符规则可以应用于不同的层级。当Git查找要忽略的文件时，会按照以下顺序进行匹配：</p>
<ol>
<li>匹配当前目录下的<code>.gitignore</code>文件中的规则</li>
<li>如果未匹配到规则，则查找父目录中的<code>.gitignore</code>文件，依次向上查找，直到根目录</li>
<li>递归忽略规则适用于子目录和子文件夹</li>
</ol>
<p>如果存在相同的规则，Git会应用最接近要忽略的文件的规则。</p>
<h3 id="gitignore忽略规则的匹配语法"><code>.gitignore</code>忽略规则的匹配语法</h3>
<p>在<code>.gitignore</code>文件中，每一行的忽略规则的语法如下：</p>
<ul>
<li>空格不匹配任意文件，可作为分隔符，可用反斜杠转义。</li>
<li>以<code>#</code>开头的行都会被Git忽略。即<code>#</code>开头的文件标识注释，可以使用反斜杠进行转义。</li>
<li>可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。</li>
<li>以斜杠<code>/</code>开头表示当前<code>.gitignore</code>文件所在的目录（根目录），以斜杠<code>/</code>结尾表示要忽略整个目录及其所有内容。</li>
<li>以星号<code>*</code>通配多个字符，即匹配多个任意字符；使用两个星号<code>**</code> 表示匹配任意中间目录，比如<code>a/**/z</code>可以匹配 <code>a/z</code>, <code>a/b/z</code> 或 <code>a/b/c/z</code>等。</li>
<li>以问号<code>?</code>通配单个字符，即匹配一个任意字符。</li>
<li>以方括号<code>[]</code>包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如<code>[abc]</code>表示要么匹配一个<code>a</code>，要么匹配一个<code>b</code>，要么匹配一个<code>c</code>；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如<code>[0-9]</code>表示匹配所有<code>0</code>到<code>9</code>的数字，<code>[a-z]</code>表示匹配任意的小写字母）。</li>
<li>以叹号<code>!</code>表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号<code>!</code>取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用<code>!</code>规则是不起作用的。也就是说<code>!</code>开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用<code>!</code>也不会再次被包含。可以使用反斜杠进行转义。</li>
</ul>
<p>示例：</p>
<blockquote>
<p>配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs git"># comment  // 表示此行为注释，将被Git忽略<br><br>/text.txt  // 忽略位于根目录下的 text.txt 文件<br>/test/text.txt  // 忽略一个位于根目录下的 test 目录中的 text.txt 文件。同 test/text.txt<br>text.txt  // 忽略任何 text.txt 文件<br><br>img*  // 忽略所有名字以 img 开头的文件和目录<br>*.md  // 忽略位于项目中任何地方的以 .md 为扩展名的任何文件<br>!README.md  // 但不忽略 README.md 文件<br>!/bin/run.sh  // 表示不忽略bin目录下的run.sh文件<br><br>debug/*.obj  // 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj<br>doc/*.txt  // 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt<br><br>**/foo  // 表示忽略/foo,a/foo,a/b/foo等<br>a/**/b  // 表示忽略a/b, a/x/b,a/x/y/b等<br><br>test/  // 忽略位于你的项目中任何地方的名为 test 的目录（包括目录中的其他文件和其他子目录）<br>!test/example.md  // 试图在一个被忽略的目录内排除一个文件是行不通的<br><br>test/*  // 忽略位于你的项目中任何地方的名为 test 的目录中的文件，但不忽略该目录<br>!test/example.md  // 这里可以在一个被忽略的目录内排除一个文件<br>!test/example/  // 在被忽略的目录内排除一个文件夹<br>!test/example  // 在被忽略的目录内排除名为example文件和文件夹<br><br>/test/  // 只忽略当前目录（根目录）下的test文件夹<br>/test  // 同时忽略当前目录（根目录）下的test文件和文件夹<br>test  // 同时忽略任何带有这个名字的文件或目录<br></code></pre></td></tr></table></figure>
<h3 id="问题与解决">问题与解决</h3>
<p><mark>问题1：</mark></p>
<p>情况：<code>.gitignore</code>中已经标明忽略的文件目录下的文件，但<code>git push</code>的时候还会出现在<code>push</code>的目录中，或者用<code>git status</code>查看状态，想要忽略的文件还是显示被追踪状态。原因：在 Git 中，当你在 <code>.gitignore</code> 文件中添加一个文件夹（或文件）到忽略列表时，Git 的行为取决于该文件夹是否<strong>已经被版本控制跟踪</strong>。以下是详细的解释：</p>
<ul>
<li>如果文件夹 <strong>已经被 Git 跟踪</strong>，你需要先清除 Git 的缓存（<code>git rm --cached</code>），然后通过 <code>.gitignore</code> 忽略它。</li>
<li>如果文件夹 <strong>未被 Git 跟踪</strong>，只需要直接在 <code>.gitignore</code> 文件中添加规则即可。</li>
<li><code>.gitignore</code> 只对未被 Git 跟踪的内容生效，对已经被跟踪的内容无效。</li>
</ul>
<p>解决：这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> -r --cached .  <span class="hljs-comment"># or</span><br><span class="hljs-comment"># git rm --cached directory/.env  # 只删除特定文件的缓存</span><br>git add .<br>git commit -m <span class="hljs-string">&#x27;update .gitignore&#x27;</span><br>git push -u origin master<br></code></pre></td></tr></table></figure>
<p><mark>问题2：</mark></p>
<p>需求：在使用<code>.gitignore</code>文件后如何删除远程仓库中以前上传的此类文件而保留本地文件。在使用git和github的时候，之前没有写<code>.gitignore</code>文件，就上传了一些没有必要的文件，在添加了<code>·</code>文件后，就想删除远程仓库中的文件却想保存本地的文件。</p>
<p>解决：这时候不可以直接使用<code>git rm directory</code>，这样会删除本地仓库的文件。可以使用<code>git rm -r –-cached directory</code>来删除缓冲，然后进行<code>git commit</code>和<code>git push</code>。这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用<code>git add -A</code>来添加修改的内容，上传的文件就会受到<code>.gitignore</code>文件的内容约束。</p>
<h2 id="将远程仓库设置为本地目录">将远程仓库设置为本地目录</h2>
<h3 id="背景知识">背景知识</h3>
<p>远端仓库实际上储存的是一个裸仓库。裸仓库命名上一般以仓库名+<code>.git</code>，比如<code>repo.git</code>，本地仓库就叫<code>repo</code>。如果你去GitHub上<code>clone</code>一个项目，你会发现地址是以<code>.git</code>结尾的：<a target="_blank" rel="noopener" href="https://github.com/raulmur/ORB_SLAM2.git%E3%80%82">https://github.com/raulmur/ORB_SLAM2.git。</a></p>
<p>查看本地仓库配置<code>./.git/config</code>, 你会发现, 本地仓库就是用这个裸仓库的地址查询和更新代码的：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">c4r:chromeExtPIP$ cat .git/config <br>...<br><br>[remote &quot;origin&quot;]<br>	url = https://github.com/raulmur/ORB_SLAM2.git<br>	fetch = +refs/heads/*:refs/remotes/origin/*<br>...<br></code></pre></td></tr></table></figure>
<p>这个裸仓库地址是可以你能访问的任意地方，不一定是github或其他仓库托管网站。所以说，你完全可以创建一个裸仓库在硬盘里，然后把本地仓库的地址指向硬盘就可以了：</p>
<blockquote>
<p>用<code>git init</code>初始化的远程仓库的话用户也可以在该目录下执行所有<code>git</code>方面的操作，但在本地库执行<code>git push</code>向其推送代码时是会报错的，因为此时远程仓库不知道本地仓库是否也在对工作副本进行了修改，直接<code>push</code>过去可能造成<code>working copy</code>的冲突。</p>
<p>解决办法就是使用<code>git init –bare</code>方法创建一个所谓的裸仓库，之所以叫裸仓库是因为这个仓库只保存<code>git</code>历史提交的版本信息，而不允许用户在上面进行各种<code>git</code>操作，如果你硬要操作的话，只会得到下面的错误（”This operation must be run in a work tree”）。</p>
<p>这个就是最好把远端仓库初始化成<code>bare</code>仓库的原因。</p>
</blockquote>
<h3 id="实际操作">实际操作</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在本地创建远程仓库</span><br><span class="hljs-built_in">cd</span> /path/to/repo_remote<br>git init --bare<br><span class="hljs-comment"># 关联本地仓库和远程仓库</span><br><span class="hljs-built_in">cd</span> /path/to/repo_local<br>git remote add remoteName ./path/to/repo_remote  <span class="hljs-comment"># 方便地用remoteName来代替完整的路径</span><br><span class="hljs-comment"># 之后的操作与上文的提交文件相同</span><br><span class="hljs-comment"># 就算repo_local文件夹被移除，也可以通过以下操作repo_remote的方法来获取原内容</span><br><br><span class="hljs-comment"># 在另一个文件夹clone原仓库</span><br>git <span class="hljs-built_in">clone</span> /path/to/repo_local  <span class="hljs-comment"># or</span><br>git <span class="hljs-built_in">clone</span> /path/to/repo_remote<br><br><span class="hljs-comment"># 另一个位置（电脑）想pull代码</span><br><span class="hljs-built_in">cd</span> /path/to/repo_other<br>git init<br>git remote add remoteName ./path/to/repo_remote<br>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br></code></pre></td></tr></table></figure>
<h1 id="高阶操作">高阶操作</h1>
<h2 id="分支checkout">分支checkout</h2>
<blockquote>
<p>分支策略：</p>
<ul>
<li>
<p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
</li>
<li>
<p>bug分支：在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>在各自分支的修改不会同步到其他分支，除非手动进行分支合并。使用<code>git checkout</code>切换分支后，在上一分支的修改不会同步到这一分支。</p>
</blockquote>
<blockquote>
<p>分支会继承被分支前的commit信息。</p>
</blockquote>
<blockquote>
<p>如果在一分支做了文件修改，但没有<code>git add .</code>和<code>git commit</code>，而直接使用<code>git checkout</code>切换分支，会报错：</p>
<p>error: Your local changes to the following files would be overwritten by checkout:<br>
filename<br>
Please commit your changes or stash them before you switch branches.<br>
Aborting</p>
</blockquote>
<h3 id="查看分支">查看分支</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看分支</span><br>git branch  <span class="hljs-comment"># 列出所有本地分支，分支前的*号表示“当前所在的分支”</span><br>git branch -r  <span class="hljs-comment"># 列出所有远程分支</span><br>git branch -a  <span class="hljs-comment"># 列出所有本地分支和远程分支</span><br></code></pre></td></tr></table></figure>
<h3 id="创建-切换分支">创建/切换分支</h3>
<h4 id="GitFlow流程">GitFlow流程</h4>
<p>GitFlow 是一种Git工作流，这个工作流程围绕着project的发布（release）定义了一个严格的如何建立分支的模型。它是团队成员遵守的一种代码管理方案。以下是基于<a target="_blank" rel="noopener" href="https://nvie.com/posts/a-successful-git-branching-model/">Vincent Driessen提出的GitFlow流程</a>图：</p>
<img src="/posts/5b8fd703/GitFlow%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload class="" title="GitFlow流程图">
<ul>
<li><code>Production</code>分支。
<ul>
<li>也就是我们经常使用的<code>Master</code>分支，这个分支最近发布到生产环境的代码，最近发布的<code>Release</code>，这个分支只能从其他分支合并，不能在这个分支直接修改。</li>
<li>所有在<code>Master</code>分支上的<code>Commit</code>应该打上<code>Tag</code>，一般情况下<code>Master</code>不存在<code>Commit</code>，<code>Develop</code>分支基于<code>Master</code>分支创建。</li>
</ul>
</li>
<li>Develop 分支。
<ul>
<li>这个分支是我们是我们的主开发分支，包含所有要发布到下一个<code>Release</code>的代码，这个主要合并与其他分支，比如<code>Feature</code>分支。</li>
<li>
<img src="/posts/5b8fd703/Master%E5%92%8CDevelop%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" lazyload class="" title="Master和Develop分支">
</li>
</ul>
</li>
<li><code>Feature</code>分支。
<ul>
<li>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回<code>Develop</code>分支进入下一个<code>Release</code>。</li>
<li><code>Feature</code>分支做完后，必须合并回<code>Develop</code>分支, 合并完分支后一般会删点这个<code>Feature</code>分支，毕竟保留下来意义也不大。</li>
<li>
<img src="/posts/5b8fd703/Feature%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" lazyload class="" title="Feature分支">
</li>
</ul>
</li>
<li><code>Release</code>分支。
<ul>
<li>当你需要一个发布一个新<code>Release</code>的时候，我们基于<code>Develop</code>分支创建一个<code>Release</code>分支，完成<code>Release</code>后，我们合并到<code>Master</code>和<code>Develop</code>分支。</li>
<li><code>Release</code>分支基于<code>Develop</code>分支创建，打完<code>Release</code>分支之后，我们可以在这个<code>Release</code>分支上测试，修改<code>Bug</code>等。同时，其它开发人员可以基于<code>Develop</code>分支新建<code>Feature</code>（记住：一旦打了<code>Release</code>分支之后不要从<code>Develop</code>分支上合并新的改动到<code>Release</code>分支）发布<code>Release</code>分支时，合并<code>Release</code>到<code>Master</code>和<code>Develop</code>，同时在<code>Master</code>分支上打个<code>Tag</code>记住<code>Release</code>版本号，然后可以删除<code>Release</code>分支了。</li>
<li>
<img src="/posts/5b8fd703/Release%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" lazyload class="" title="Release分支">
</li>
</ul>
</li>
<li><code>Hotfix</code>分支。
<ul>
<li>当我们在<code>Production</code>发现新的<code>Bug</code>时候，我们需要创建一个<code>Hotfix</code>，完成<code>Hotfix</code>后，我们合并回<code>Master</code>和<code>Develop</code>分支，所以<code>Hotfix</code>的改动会进入下一个<code>Release</code>。</li>
<li><code>Hotfix</code>分支基于<code>Master</code>分支创建，开发完后需要合并回<code>Master</code>和<code>Develop</code>分支，同时在<code>Master</code>上打一个<code>tag</code>。</li>
<li>
<img src="/posts/5b8fd703/Hotfix%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" lazyload class="" title="Hotfix分支">
</li>
</ul>
</li>
</ul>
<h4 id="分支命名规范">分支命名规范</h4>
<p>通用的Git分支命名规范示例：</p>
<blockquote>
<p>推荐使用小写字母来命名分支，并使用连字符（<code>-</code>）来替代空格或其他符号，以保持URL的友好性。</p>
<p>除连字符外，应避免使用其他特殊字符如空格、波折号（<code>_</code>）等，因为这些字符可能在不同系统或脚本中引起歧义。</p>
</blockquote>
<ul>
<li>
<p>主分支：</p>
<ul>
<li><code>main</code>或<code>master</code>：主分支，存放产品的正式发布版本。</li>
<li><code>develop</code>或<code>dev</code>：开发分组的主分支，用于集成各种功能分支的更改。</li>
</ul>
</li>
<li>
<p>功能（Feature）分支：</p>
<ul>
<li><code>feature/</code></li>
<li><code>feat/</code></li>
</ul>
<p>例如: <code>feature/login-auth</code>, <code>feat/user-profile</code></p>
</li>
<li>
<p>修复（Bugfix）分支：</p>
<ul>
<li><code>bugfix/</code></li>
<li><code>fix/</code></li>
</ul>
<p>例如: <code>bugfix/login-error</code>, <code>fix/api-crash</code></p>
</li>
<li>
<p>发布（Release）分支：</p>
<ul>
<li><code>release/</code></li>
</ul>
<p>例如: <code>release/1.0.0</code></p>
</li>
<li>
<p>紧急修复（Hotfix）分支：</p>
<ul>
<li><code>hotfix/</code></li>
</ul>
<p>例如: <code>hotmodefix/typo-in-homepage</code></p>
</li>
<li>
<p>文档（Documentation）分支：</p>
<ul>
<li><code>docs/</code></li>
</ul>
<p>例如: <code>docs/installation-guide</code></p>
</li>
<li>
<p>其他类型的分支也可能包括：</p>
<ul>
<li><code>experiment/</code>: 用于试验性的探索或研究。</li>
<li><code>optimize/</code>: 用于性能优化相关的更改。</li>
<li><code>test/</code>: 专门用来处理测试相关的任务。</li>
</ul>
</li>
</ul>
<h4 id="基本语法-2">基本语法</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -h  <span class="hljs-comment"># 帮助</span><br><br><span class="hljs-comment"># 创建分支</span><br>git branch otherBranch  <span class="hljs-comment"># 创建了一个名为otherBranch的分支，但依然停留在当前分支</span><br>git checkout otherBranch  <span class="hljs-comment"># 切换到otherBranch分支，并更新工作区</span><br>git checkout -b otherBranch  <span class="hljs-comment"># 直接创建并切换到了一个名为otherBranch的分支</span><br>git checkout --orphan &lt;new-branch&gt;  <span class="hljs-comment"># 创建一个全新的分支，不包含原分支的提交历史</span><br><br>git checkout -  <span class="hljs-comment"># 快速切换回前一个分支，无需记住分支名称</span><br><br><br>git branch [branch] [commit]  <span class="hljs-comment"># 新建一个分支，指向指定commit</span><br>git checkout -b [branch] [tag]  <span class="hljs-comment"># 新建一个分支，指向某个tag</span><br><br>git branch --track [branch] [remote-branch]  <span class="hljs-comment"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>git branch --set-upstream [branch] [remote-branch]  <span class="hljs-comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><br>git checkout -- &lt;file&gt;  <span class="hljs-comment"># 将指定文件 &lt;file&gt; 恢复到最新的提交状态，丢弃所有未提交的更改，这对于撤销不需要的更改非常有用</span><br>git checkout .  <span class="hljs-comment"># 放弃工作区中全部的修改</span><br><br>git checkout &lt;commit-hash&gt;  <span class="hljs-comment"># 切换到特定提交。你可以使用提交的哈希值 &lt;commit-hash&gt; 来切换到特定的提交状态。这将使你进入&quot;分离头指针&quot;状态，只能查看历史记录，而不能进行分支操作。通常情况下，不建议在分离头指针状态下工作，因为更改可能会丢失。</span><br>git checkout tags/&lt;tag-name&gt;  <span class="hljs-comment"># 切换到标签。如果你有一个标签 &lt;tag-name&gt;，你可以使用这个命令来切换到该标签所指向的提交状态。</span><br></code></pre></td></tr></table></figure>
<h3 id="合并分支">合并分支</h3>
<h4 id="合并merge">合并merge</h4>
<h5 id="基本语法-3">基本语法</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 合并分支</span><br>git checkout master  <span class="hljs-comment"># 切换到master分支</span><br>git merge -m <span class="hljs-string">&quot;message&quot;</span> otherBranch  <span class="hljs-comment"># 将otherBranch分支合并到master分支。默认提交信息为“Merge branch &#x27;otherBranch&#x27;”</span><br><span class="hljs-comment"># 通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。</span><br>git merge –no-ff -m <span class="hljs-string">&quot;message&quot;</span> otherBranch<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在合并分支的时候，要考虑到两个分支是否有冲突，如果有冲突，则不能直接合并，需要先自行解决冲突；反之，则可以直接合并。</p>
</blockquote>
<blockquote>
<p>从旧分支上继承的新分支，做出修改后，可以直接合并到旧分支（不会触发冲突）。如果旧分支在此期间也做出了修改，则会触发冲突。</p>
</blockquote>
<h5 id="Git合并时-no-ff的作用">Git合并时<code>--no-ff</code>的作用</h5>
<p>在许多介绍 Git 工作流的文章里，都会推荐在合并分支时，加上<code>--no-ff</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout develop<br>git merge --no-ff feature<br></code></pre></td></tr></table></figure>
<p><code>--no-ff</code>在这的作用是禁止快进式合并。</p>
<p>Git 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward），比如下图：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">          A---B---C feature<br>         /<br>D---E---F master<br></code></pre></td></tr></table></figure>
<p>要把 feature 合并到 master 中，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git merge feature<br></code></pre></td></tr></table></figure>
<p>结果就会变成：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">          A---B---C feature<br>         /         master<br>D---E---F <br></code></pre></td></tr></table></figure>
<p>因为 feature 就在 master 的下游，所以直接移动了 master 的指针，master 和 feature 都指向了 C。而如果执行了<code>git merge --no-ff feature</code>的话，是下面的结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">          A---B---C feature<br>         /         \<br>D---E---F-----------G master<br></code></pre></td></tr></table></figure>
<p>由于<code>--no-ff</code>禁止了快进，所以会生成一个新的提交，master 指向 G。</p>
<p>从合并后的代码来看，结果其实是一样的，区别就在于 <code>--no-ff</code> 会让 Git 生成一个新的提交对象。为什么要这样？通常我们把 master 作为主分支，上面存放的都是比较稳定的代码，提交频率也很低，而 feature 是用来开发特性的，上面会存在许多零碎的提交，快进式合并会把 feature 的提交历史混入到 master 中，搅乱 master 的提交历史。所以如果你根本不在意提交历史，也不爱管 master 干不干净，那么 <code>--no-ff</code> 其实没什么用。不过，如果某一次 master 出现了问题，你需要回退到上个版本的时候，比如上例，你就会发现退一个版本到了 B，而不是想要的 F，因为 feature 的历史合并进了 master 里。</p>
<h4 id="变基rebase">变基rebase</h4>
<h5 id="图解（与分支合并的不同）">图解（与分支合并的不同）</h5>
<p>当您 <code>rebase</code> 一个分支到另一个分支时，您将第一个分支的提交应用到第二个分支中的 HEAD 提交之上。</p>
<p>假设您创建了一个功能分支来处理特定任务并向该分支进行了多次提交：</p>
<img src="/posts/5b8fd703/feature_branch_diagram.png" srcset="/img/loading.gif" lazyload class="" title="feature branch">
<p>当您在分支中开发时，您的队友会继续致力于掌握他们的工作：</p>
<img src="/posts/5b8fd703/feature_branch_diverge_from_master_diagram.png" srcset="/img/loading.gif" lazyload class="" title="feature branch diverged from master">
<p>当您执行 <code>rebase</code> 操作时，您可以通过将您的提交应用到 <code>master</code> 分支中&gt;：</p>
<img src="/posts/5b8fd703/rebase_result_diagram.png" srcset="/img/loading.gif" lazyload class="" title="rebase operation result">
<p>变基的主要好处是您可以获得清晰的项目历史记录，易于其他人阅读和理解。您的日志不包含 <code>merge</code> 操作生成的不必要的合并提交，并且您将获得易于导航和搜索的线性历史记录。</p>
<p>但是，当决定采用此工作流程时，您应该记住， <code>rebase</code> 会重写项目历史记录，因为它为原始功能分支中的每个提交创建新的提交，因此它们将具有不同的哈希值，这会妨碍可追溯性。</p>
<h5 id="基本语法-4">基本语法</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检出 experiment 分支，然后将它变基到 master 分支上：</span><br>git checkout experiment<br>git rebase master<br></code></pre></td></tr></table></figure>
<h3 id="删除分支">删除分支</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除分支</span><br>git branch -d otherBranch  <span class="hljs-comment"># 通过git branch -d命令可能出现删除不了现象，例如分支a的代码没有合并到主分支等</span><br>git branch -D otherBranch  <span class="hljs-comment"># 强制删除</span><br>git push origin --delete master  <span class="hljs-comment"># 删除 origin 主机的 master 分支</span><br>git branch -dr [origin/master]  <span class="hljs-comment"># 删除 origin 主机的 master 分支</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>本地仓库的删除分支操作不会影响到远程仓库的分支（即使<code>git push origin -all</code>），远程仓库的分支仍需手动删除。</p>
</blockquote>
<h2 id="标签tag">标签tag</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看</span><br>git tag  <span class="hljs-comment"># 查看标签记录</span><br>git show [tag]  <span class="hljs-comment"># 查看tag信息</span><br><br><span class="hljs-comment"># 添加标签</span><br>git tag v1.0  <span class="hljs-comment"># 为当前分支的commit添加标签</span><br>git tag [tag] [commit]  <span class="hljs-comment"># # 新建一个tag在指定commit</span><br><br><span class="hljs-comment"># 提交标签</span><br>git push [remote] [tag]  <span class="hljs-comment"># 提交指定tag</span><br>git push [remote] --tags  <span class="hljs-comment"># 提交所有tag</span><br><br><span class="hljs-comment"># 删除标签</span><br>git tag -d [tag]  <span class="hljs-comment"># 删除本地tag</span><br>git push origin :refs/tags/[tagName]  <span class="hljs-comment"># 删除远程tag</span><br><br>git checkout v1.0  <span class="hljs-comment"># 切换到该标签下的代码状态</span><br></code></pre></td></tr></table></figure>
<h2 id="比较diff">比较diff</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff  <span class="hljs-comment"># 显示暂存区和工作区的差异</span><br>git diff --cached [file]  <span class="hljs-comment"># 显示暂存区和上一个commit的差异</span><br>git diff HEAD  <span class="hljs-comment"># 显示工作区与当前分支最新commit之间的差异</span><br>git diff [first-branch]...[second-branch]  <span class="hljs-comment"># 显示两次提交之间的差异</span><br>git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span>  <span class="hljs-comment"># 显示今天你写了多少行代码</span><br></code></pre></td></tr></table></figure>
<h2 id="储藏stash">储藏stash</h2>
<p>使用git的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的bug，我们往往会把完成一半的代码<code>commit</code>提交到本地仓库，然后切换分支去修改bug，改好之后再切换回来。这样的话往往log上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用<code>git stash</code>就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修Bug，等到修完Bug，提交到服务器上后，再使用<code>git stash apply</code>将以前一半的工作应用回来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br>git stash push -m <span class="hljs-string">&quot;Work in progress&quot;</span>  <span class="hljs-comment"># 储藏（移除）</span><br>git stash pop  <span class="hljs-comment"># 移入</span><br><br>git stash  <span class="hljs-comment"># Stash changes</span><br>git stash apply  <span class="hljs-comment"># Reapply stashed changes</span><br>git stash list  <span class="hljs-comment"># List stashed changes</span><br></code></pre></td></tr></table></figure>
<h2 id="回滚reset">回滚reset</h2>
<ol>
<li>
<p>找到想要回退到某个版本的版本号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br><span class="hljs-comment"># -&gt; commit auihcbuioahnaoij156651</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>找到想要回退的版本号之后，在本地 Git 仓库执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard &lt;版本号&gt;  <span class="hljs-comment"># 抛弃当前工作区的修改</span><br>git reset --soft &lt;版本号&gt;  <span class="hljs-comment"># 回退到之前的版本，但保留当前工作区的修改，可以重新提交</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>同步远端的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin &lt;分支名&gt;<br>git push origin &lt;分支名&gt; --force  <span class="hljs-comment"># 如果提示本地的版本落后于远端的版本</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>到这里，我们就可以把本地和远端的代码都回退到某一个指定的版本了。</p>
</li>
<li>
<p>如果想要回滚会最新的版本，使用<code>git log</code>命令只可以查看到HEAD指针及其之前的版本信息，如果版本发生过回退操作，则可能会出现，HEAD指针之后仍存在历史提交版本的情况，而这些提交版本信息通过<code>git log</code>命令是看不到的。我们可以通过使用<code>git reflog</code>命令，就可查看到所有历史版本信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reflog<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>之后的操作与第2步开始相同。</p>
</li>
</ol>
<h2 id="撤销最近的一次commit">撤销最近的一次commit</h2>
<p>在 Git 中，撤销最近的一次 commit 有多种方式，常见用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这样会撤回最近一次 commit，但你的改动还在暂存区（可以重新提交）。</span><br>git reset --soft HEAD~1<br><br><span class="hljs-comment"># 这样会撤回最近一次 commit，并把改动变为未暂存状态（可修改后再提交）。</span><br>git reset --mixed HEAD~1<br><span class="hljs-comment"># 或者</span><br>git reset HEAD~1<br><br><span class="hljs-comment"># 这样会撤回最近一次 commit，所有改动丢失，不可恢复！</span><br>git reset --hard HEAD~1<br><br><span class="hljs-comment"># 如果已经 push 到远程，并且要撤销。推荐用 git revert，这会生成一个新的“撤销”commit，不会影响公共历史。</span><br>git revert &lt;commit_sha&gt;<br></code></pre></td></tr></table></figure>
<h2 id="撤销修改">撤销修改</h2>
<p>方法一：如果知道要修改回的内容的话，可以直接手动更改那些需要的文件。然后<code>git add</code>添加到暂存区，最后<code>git commit</code>掉。</p>
<p>方法二：直接<a href="#%E5%9B%9E%E6%BB%9Areset">回滚</a>到上一个版本。</p>
<p>方法三：<code>git checkout -- filename</code>命令可以丢弃工作区的修改，也可以用来恢复被删除的文件。</p>
<ul>
<li>文件修改后，还没有使用<code>git add</code>添加到暂存区：使用该命令后本地文件变回与<a href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB">版本库</a>中一样的状态（内容）。</li>
<li>文件已经使用<code>git add</code>添加到<a href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB">暂存区</a>，之后又进行了修改：使用该命令后本地文件变回与添加暂存区后的状态（内容）。</li>
</ul>
<h2 id="删除rm">删除rm</h2>
<p><code>git rm</code>命令从工作目录中删除文件并为下一次提交暂存删除。这对于从存储库中删除不需要的文件非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> file.txt  <span class="hljs-comment"># Remove a file</span><br>git <span class="hljs-built_in">rm</span> -r directory/  <span class="hljs-comment"># Remove a directory</span><br></code></pre></td></tr></table></figure>
<h2 id="检查fsck">检查fsck</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fsck  <span class="hljs-comment"># 检查Git仓库的完整性</span><br></code></pre></td></tr></table></figure>
<h2 id="追溯blame">追溯blame</h2>
<ul>
<li>追溯一个指定文件的历史修改记录</li>
<li>显示文件每一行的最后修改版本和作者</li>
</ul>
<h2 id="从远程获取代码库fetch">从远程获取代码库fetch</h2>
<ul>
<li><strong><code>git fetch</code></strong>：获取远程更新，但不合并，手动控制更改。
<ul>
<li>仅更新本地的远程追踪分支（如 <code>origin/main</code>），而不影响当前工作分支。</li>
</ul>
</li>
<li><strong><code>git pull</code></strong>：获取远程更新并自动合并，快速同步更改。
<ul>
<li>是 <code>git fetch</code> 和 <code>git merge</code> 的组合操作。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin<br>git diff origin/main<br>git merge origin/main<br><br>git pull origin main<br></code></pre></td></tr></table></figure>
<h2 id="将指定的提交（commit）应用于其他分支cherry-pick">将指定的提交（commit）应用于其他分支cherry-pick</h2>
<p><code>git cherry-pick</code>命令将特定提交引入的更改应用于当前分支。这对于在分支之间移植错误修复或功能非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick abc1234  <span class="hljs-comment"># Apply changes from commit abc1234</span><br></code></pre></td></tr></table></figure>
<h2 id="设置别名alias">设置别名alias</h2>
<p>简化命令输入：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/70144578">Git 进阶之「设置别名」</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.psm <span class="hljs-string">&#x27;push origin master&#x27;</span>  -&gt; git psm<br></code></pre></td></tr></table></figure>
<h2 id="发布">发布</h2>
<h3 id="生成一个可供发布的压缩包">生成一个可供发布的压缩包</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git archive<br></code></pre></td></tr></table></figure>
<h3 id="Change-log">Change log</h3>
<p>如果你的所有Commit都符合<a href="#%E8%A7%84%E8%8C%83%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF">Angular格式</a>，那么发布新版本时，Change log就可以用脚本自动生成（<a target="_blank" rel="noopener" href="https://github.com/ajoslin/conventional-changelog/blob/master/CHANGELOG.md">例1</a>，<a target="_blank" rel="noopener" href="https://github.com/karma-runner/karma/blob/master/CHANGELOG.md">例2</a>，<a target="_blank" rel="noopener" href="https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md">例3</a>）。</p>
<p>生成的文档包括以下三个部分：</p>
<ul>
<li>New features（新特性）</li>
<li>Bug fixes（bug修复）</li>
<li>Breaking changes（重大变更）</li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<blockquote>
<p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p>
</blockquote>
<blockquote>
<p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的<code>Reverts</code>小标题下面。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ajoslin/conventional-changelog">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g conventional-changelog<br><span class="hljs-built_in">cd</span> my-project<br>conventional-changelog -p angular -i CHANGELOG.md -w<br></code></pre></td></tr></table></figure>
<p>上面命令不会覆盖以前的 Change log，只会在<code>CHANGELOG.md</code>的头部加上自从上次发布以来的变动。</p>
<p>如果你想生成所有发布的 Change log，要改为运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conventional-changelog -p angular -i CHANGELOG.md -w -r 0<br></code></pre></td></tr></table></figure>
<p>为了方便使用，可以将其写入<code>package.json</code>的<code>scripts</code>字段：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;changelog&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>以后，直接运行下面的命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run changelog<br></code></pre></td></tr></table></figure>
<h3 id="指定开源许可证">指定开源许可证</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/77647234">详述 GitHub 中声明 LICENSE 的方法</a></p>
<h2 id="将代码从原分支合并到自己的fork分支">将代码从原分支合并到自己的fork分支</h2>
<p><a target="_blank" rel="noopener" href="https://guobinhit.blog.csdn.net/article/details/98039346">详述 GitHub 如何将代码从原分支合并到 fork 分支</a></p>
<h2 id="将本地Git仓库从一块硬盘移动到另一块硬盘">将本地Git仓库从一块硬盘移动到另一块硬盘</h2>
<ol>
<li>
<p>确保当前的工作目录没有未提交的更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>备份你的Git仓库。在进行移动之前，首先应该备份你的Git仓库，以防止意外数据丢失。可以通过以下命令将仓库备份到另一个位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -R /path/to/old/repository /path/to/backup/location<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>克隆一个临时仓库。在新硬盘上创建一个临时目录，并通过以下命令克隆原始仓库到临时目录中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> /path/to/old/repository /path/to/new/temp/repository<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>检查新仓库是否正常工作。在新硬盘上创建一个临时目录，并通过以下命令克隆原始仓库到临时目录中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/new/temp/repository<br>git status<br></code></pre></td></tr></table></figure>
<p>确保没有任何错误或冲突。如果有错误，需要解决它们，然后再继续下一步。</p>
</li>
<li>
<p>将本地分支推送到新仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/new/temp/repository<br>git remote add new-origin /path/to/new/repository<br>git push new-origin --all<br></code></pre></td></tr></table></figure>
<p>这将把所有本地分支以及相关的提交推送到新仓库中。</p>
</li>
<li>
<p>更新远程仓库地址。切换到原始仓库中，并更新远程仓库的地址为新仓库的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/old/repository<br>git remote set-url origin /path/to/new/repository<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>测试新仓库是否正常工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/new/repository<br>git status<br></code></pre></td></tr></table></figure>
<p>检查是否有错误或冲突。如果一切正常，那么新仓库就已经成功迁移了。</p>
</li>
<li>
<p>删除临时仓库。现在你可以删除临时目录，因为新仓库已经在新硬盘上建立并正常工作了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /path/to/new/temp/repository<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>大功告成。</p>
</li>
</ol>
<h2 id="在两台机器间同步代码">在两台机器间同步代码</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/elloop/article/details/54898512">使用git在两台机器间同步代码</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352824096">自己有两台电脑,如何使用git同步文件</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33692349/article/details/101607394">windows环境下搭建git远程仓库用于局域网内团队开发</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关键操作</span><br><span class="hljs-comment"># 关联远程仓库</span><br>git remote add origin //IP地址/共享文件夹名称<br>git remote add origin ssh://服务器名@服务器IP地址/服务器git仓库路径<br>git <span class="hljs-built_in">clone</span> ssh://&lt;username&gt;@&lt;ip&gt;:&lt;port&gt;:/codes/project-bare/project-bare.git ./project<br></code></pre></td></tr></table></figure>
<h2 id="删除当前目录下的-Git-仓库">删除当前目录下的 Git 仓库</h2>
<p>要删除当前目录下的 Git 仓库，你实际上需要删除这个目录中的 <code>.git</code> 文件夹。这个 <code>.git</code> 文件夹包含了所有 Git 相关的跟踪信息和对象数据库，一旦删除，这个目录就不再是一个 Git 仓库了。</p>
<blockquote>
<p>这是一个不可逆操作，将会丧失所有版本控制信息。在执行此操作前，请确保确实希望删除所有与 Git 仓库相关的数据，或已经做好了相应的备份。</p>
</blockquote>
<p>在 Linux 或 macOS 终端中，你可以使用以下命令来删除 <code>.git</code> 文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf .git<br></code></pre></td></tr></table></figure>
<p>在 Windows 命令行中，你可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> /s /q .git<br></code></pre></td></tr></table></figure>
<p>这些命令将递归地删除 <code>.git</code> 目录及其所有内容，从而永久地从你的工作目录中移除 Git 版本控制。</p>
<p>执行完毕后，当前目录就不再是一个 Git 仓库，所有版本控制历史都会被删除。如果你的项目中还有其他重要的文件或数据，它们不会被这个操作影响。</p>
<h2 id="使用git来比较两个文件夹">使用git来比较两个文件夹</h2>
<p>假设你有两个文件夹：</p>
<ol>
<li><strong>文件夹 A</strong>：现有文件夹，包含旧数据或当前正在使用的内容。</li>
<li><strong>文件夹 B</strong>：来自另一个仓库或文件夹，包含需要引入或对比的内容。</li>
</ol>
<h3 id="使用checkout">使用checkout</h3>
<ol>
<li>
<p>创建 Git 仓库。将文件夹 A 和文件夹 B 添加到一个 Git 仓库中。</p>
<ol>
<li>
<p>初始化仓库并添加文件夹 A：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/folderA<br>git init<br>git add .<br>git commit -m <span class="hljs-string">&quot;Initial commit with folder A&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>创建一个新分支用于文件夹 B：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b folderB<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>将文件夹 B 的内容拷贝到当前目录（或者直接引入文件夹 B 的路径）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -r /path/to/folderB /path/to/folderA<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>提交文件夹 B 的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Added content from folder B&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>完成。</p>
</li>
</ol>
</li>
<li>
<p>比较两个文件夹。通过 Git 的分支合并功能，可以比较文件夹 A 和文件夹 B 的差异。</p>
<ol>
<li>
<p>切回主分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>合并分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge folderB<br></code></pre></td></tr></table></figure>
<p>如果文件夹 A 和文件夹 B 存在差异，Git 会提示冲突。你可以手动解决冲突，并决定如何迁移或保留文件。</p>
</li>
<li>
<p>完成。</p>
</li>
</ol>
</li>
<li>
<p>查看差异。</p>
<ol>
<li>
<p>在 <code>git merge</code> 过程中，使用 <code>git status</code> 查看有哪些文件发生了冲突或修改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>通过 <code>git diff</code> 查看具体的文件差异：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br>git diff --merge  <span class="hljs-comment"># 查看冲突文件的内容差异</span><br>git diff &lt;file-path&gt;  <span class="hljs-comment"># 查看特定文件的差异</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>完成。</p>
</li>
</ol>
</li>
<li>
<p>解决冲突。如果文件夹 A 和文件夹 B 中的文件内容有冲突，Git 会在文件中标记冲突位置，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">内容来自文件夹 A</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">内容来自文件夹 B</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; folderB</span><br></code></pre></td></tr></table></figure>
<ol>
<li>
<p>手动解决冲突。编辑冲突的文件，手动选择保留的内容。例如：</p>
<ul>
<li>保留文件夹 A 的内容。</li>
<li>或者合并两者的内容。</li>
</ul>
<p>编辑后，标记冲突已解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;file-path&gt;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>自动解决冲突。如果你确定要保留某一分支的内容，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --ours &lt;file-path&gt;  <span class="hljs-comment"># 保留文件夹 A 的内容（主分支内容）</span><br>git checkout --theirs &lt;file-path&gt;  <span class="hljs-comment"># 保留文件夹 B 的内容（分支内容）</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>完成。</p>
</li>
</ol>
</li>
<li>
<p>提交合并结果。解决所有冲突后，提交合并结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Resolved conflicts and merged folder B into folder A&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>（可选）生成迁移报告：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff --name-status HEAD  <span class="hljs-comment"># 查看已改变或新增的文件</span><br>git diff --name-status HEAD &gt; migration_report.txt  <span class="hljs-comment"># 导出到文件</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>完成。</p>
</li>
</ol>
<h3 id="使用pull">使用pull</h3>
<ol>
<li>
<p>初始化本地仓库。如果你的本地文件夹 A 还不是一个 Git 仓库，先初始化它。同上。</p>
</li>
<li>
<p>将远程仓库 B 添加为本地仓库的一个远程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/folderB<br>git init<br><br><span class="hljs-built_in">cd</span> /path/to/folderA<br>git remote add origin /path/to/folderB<br>git remote -v  <span class="hljs-comment"># 查看远程仓库是否添加成功</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>拉取远程分支。使用 <code>git fetch</code> 拉取远程仓库的内容，但不合并到本地分支。这一步可以让你安全地查看远程仓库内容，而不会影响本地文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>比较本地和远程的差异：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff HEAD origin/main  <span class="hljs-comment"># 显示本地文件夹 A 和远程仓库 B 中 main 分支的具体文件差异。</span><br><span class="hljs-comment"># 根据这些差异，你可以决定是否迁移文件。</span><br><br><span class="hljs-comment"># 如果你想知道哪些文件会被覆盖或冲突，可以尝试合并分支，但不要提交：</span><br>git merge --no-commit origin/main<br>git status  <span class="hljs-comment"># 查看哪些文件有冲突或需要迁移</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>决定迁移方式。</p>
<ol>
<li>
<p>覆盖本地内容。如果远程仓库 B 的内容更重要，你可以直接覆盖本地内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard origin/main  <span class="hljs-comment"># 放弃本地更改，保留远程版本</span><br>git clean -fd  <span class="hljs-comment"># 如果有多余的未跟踪文件，可以清理这些文件</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>保留本地内容。如果你希望保留本地文件夹 A 的内容，并且只合并必要的文件，可以通过解决冲突的方式完成迁移：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge origin/main  <span class="hljs-comment"># 合并远程分支</span><br></code></pre></td></tr></table></figure>
<p>如果有冲突，Git 会提示冲突文件：</p>
<ul>
<li>
<p>编辑冲突文件，手动合并内容。</p>
</li>
<li>
<p>标记冲突已解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;file-path&gt;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>提交合并结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Merged remote changes into local branch&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>完成。</p>
</li>
</ol>
</li>
<li>
<p>（可选）生成迁移报告。同上。</p>
</li>
<li>
<p>完成。</p>
</li>
</ol>
<h1 id="问题与解决-2">问题与解决</h1>
<h2 id="只修改了一个文件，git却显示所有文件被修改了？">只修改了一个文件，git却显示所有文件被修改了？</h2>
<p>原因：不同操作系统使用的换行符是不一样的。Unix/Linux使用的是LF，Mac后期也采用了LF，但Windows一直使用CRLF【回车(CR, ASCII 13, r) 换行(LF, ASCII 10, n)】作为换行符。而git入库的代码采用的是LF格式，它考虑到了跨平台协作的场景，提供了“换行符自动转换”的功能。在Windows下使用git，在拉取文件时，会自动将LF换行符替换为CRLF；在提交时，又会将CRLF转回LF。就是这个转换有问题的。</p>
<p>解决：对git进行全局配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.autocrlf <span class="hljs-literal">false</span><br>git config --global core.filemode <span class="hljs-literal">false</span><br>git config --global core.safecrlf <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<h2 id="git-fsck命令检测到缺少的-blob-对象"><code>git fsck</code>命令检测到缺少的 blob 对象</h2>
<p>当<code>git fsck</code>命令检测到缺少的 blob 对象时，这通常说明你的 Git 仓库数据有损坏。Blob 对象是 Git 用来存储文件内容的数据结构。在这种情况下，一些文件的内容丢失了，这可能是由于磁盘错误、Git 操作错误或其他系统错误导致的。</p>
<p>要解决这个问题，你可以尝试以下几个步骤：</p>
<ol>
<li>
<p>从其他克隆恢复缺失的对象。</p>
<p>如果你有这个仓库的其他克隆（比如在其他机器上或者同事的机器上），尝试在那些仓库中找到丢失的 blobs。你可以在其他克隆的仓库上运行以下命令来检查是否存在缺失的 blob：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cat-file -t &lt;blob-sha1&gt;<br></code></pre></td></tr></table></figure>
<p>如果命令有输出（通常是 <code>blob</code>），那么你可以从这个克隆中复制丢失的对象到你的仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在有完整对象的仓库中运行</span><br>git cat-file -p &lt;blob-sha1&gt; &gt; filename<br><br><span class="hljs-comment"># 然后将这个文件移动到损坏仓库的相应目录中</span><br><span class="hljs-built_in">cp</span> filename /path/to/broken-repository/.git/objects/b0/<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>检查备份。</p>
<p>如果你的仓库定期备份，检查备份是否可以用来恢复丢失的数据。</p>
</li>
<li>
<p>克隆新的副本并重新应用更改。</p>
<p>如果上述方法都无法恢复数据，最简单的方法可能是重新克隆仓库的一个新副本（如果远程仓库没有损坏的话）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;repository-url&gt;<br></code></pre></td></tr></table></figure>
<p>然后，如果你本地有些未推送的更改或者新的提交，尝试手动将这些更改重新应用到新克隆的仓库中。</p>
</li>
<li>
<p>使用 <code>git-reflog</code> 和 <code>git reset</code></p>
<p>如果损坏是最近发生的，你可以尝试用 <code>git reflog</code> 查找到损坏前的一个好的状态，然后用 <code>git reset --hard &lt;good-commit-sha1&gt;</code> 来恢复到那个状态。</p>
</li>
</ol>
<p>利用这些方式，你应该能恢复大部分数据，或者至少能找到足够的信息重建你的项目。处理完后不要忘记重新执行 <code>git fsck</code> 来确保所有问题都解决了。</p>
<h2 id="git文件夹下嵌套git文件夹">git文件夹下嵌套git文件夹</h2>
<p>在Git中，每个<code>.git</code>目录表示一个单独的Git仓库。因此，如果在<code>folder_1/</code>中有一个Git仓库，而在其子文件夹<code>folder_2/</code>中也有一个Git仓库，那么这两个仓库是独立的，互不干涉。</p>
<p>要让 <code>folder_1/</code> 中的 Git 仓库跟踪 <code>folder_2/</code> 中的文件变化，可以采用以下几种方法：</p>
<ol>
<li>
<p>如果你不需要 <code>folder_2/</code> 作为一个独立的 Git 仓库，可以删除 <code>folder_2/</code> 中的 <code>.git</code> 目录。这样，<code>folder_2/</code> 中的文件就会被 <code>folder_1/</code> 中的 Git 仓库跟踪。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf folder_2/.git<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>如果你需要 <code>folder_2/</code> 保持为一个独立的 Git 仓库，并且希望在 <code>folder_1/</code> 的 Git 仓库中跟踪 <code>folder_2/</code> 的变化，可以使用 Git 子模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> folder_1<br>git submodule add &lt;folder_2_repository_url&gt; folder_2<br>git commit -m <span class="hljs-string">&quot;Add folder_2 as a submodule&quot;</span><br></code></pre></td></tr></table></figure>
<p>这样，<code>folder_2/</code> 的变化将独立于 <code>folder_1/</code>，但 <code>folder_1/</code> 中的 Git 仓库会跟踪 <code>folder_2/</code> 的版本变化。</p>
</li>
<li>
<p>等等。</p>
</li>
</ol>
<h1 id="CLion中的Git">CLion中的Git</h1>
<h2 id="相关操作">相关操作</h2>
<p><a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/using-git-integration.html">官方文档</a></p>
<blockquote>
<p>在“文件-设置-版本控制-Git-Git可执行文件路径“中配置Git的安装路径（自动检测？）。</p>
</blockquote>
<blockquote>
<p>在“文件-设置-版本控制-文件状态颜色”中定义了多种目录中文件状态的颜色。</p>
</blockquote>
<h3 id="启用Git">启用Git</h3>
<ol>
<li>在主菜单中，转至 VCS |启用版本控制集成。</li>
<li>在打开的对话框中，从可用版本控制系统列表中选择 Git，然后单击“确定”。或者，按 Alt+` 并选择“创建 Git 存储库”（或按 1 ）。在打开的 Finder 窗口中，指定本地 Git 存储库的根文件夹。</li>
<li>您将收到一条通知，表明已为您的项目创建本地 Git 存储库。工具栏和状态栏上会出现Git相关的控件。</li>
<li>从左侧提交工具窗口 Alt+0 中，您可以查看本地更改并将其提交到本地 Git 存储库。在 下方 Git 工具窗口Alt+9中，您可以使用 Git 日志、管理来自 GitHub 的拉取请求等。</li>
</ol>
<h3 id="将文件添加到-gitignore">将文件添加到<code>.gitignore</code></h3>
<ol>
<li>在“提交”工具窗口 Alt+0 的“本地更改”选项卡上，您会看到属于您的项目的文件列表。这些文件尚未添加到 Git 存储库 - 您需要选择要共享哪些文件以及 VCS 应忽略哪些文件。</li>
<li>按目录对文件进行分组：按 Ctrl+Alt+P或单击工具栏上的&quot;四个小方块&quot;并选择“目录”。</li>
<li>选择您不想共享的目录。例如，可以忽略以下目录，而不会破坏项目的完整性：
<ul>
<li><code>.idea</code>：本地 CLion 安装的设置。除非您想在团队成员之间共享您的设置，否则请忽略此目录。</li>
<li><code>cmake-build-debug</code>：为 CMake 构建工件自动创建的目录。</li>
</ul>
</li>
<li>右键单击所选内容并选择添加到 .gitignore |添加到 .gitignore。</li>
<li>系统将提示您确认在项目的根目录中创建新的 .gitignore 文件。单击“创建”。</li>
<li>在打开的对话框中，您可以按“添加”立即将新创建的文件添加到 Git，也可以按“取消”推迟此操作。单击“添加”。您将看到 <code>.gitignore</code> 文件已添加到项目的根目录并放置到 Changes 区域。您选择忽略的目录不再显示在“无版本控制文件”列表中。</li>
<li>您可以随时编辑 <code>.gitignore</code> 文件以将新目录添加到列表中或删除现有目录。</li>
</ol>
<h3 id="提交并推送更改">提交并推送更改</h3>
<p>现在，当所有不必要的目录都从未版本控制的文件列表中排除时，您只需将所有文件添加到存储库并提交它们以保存其当前状态。</p>
<h4 id="基本用法">基本用法</h4>
<ol>
<li>
<p>在“提交”工具窗口 Alt+0中，使用拖放操作将所有文件从“未版本化文件”列表移动到“更改”。通过单击根文件夹复选框选择（所有）文件（<code>git add</code>）。</p>
<blockquote>
<p>在提交工具窗口中，您还可以预览添加和修改的文件、使用高级提交选项、在提交中添加和排除文件等。</p>
</blockquote>
</li>
<li>
<p>在“提交”工具窗口的下方“提交信息”处为您的提交输入提交信息（<code>git commit</code>）。</p>
</li>
<li>
<p>单击“提交”。执行提交后会出现相应的通知。</p>
</li>
<li>
<p>按 Ctrl+Shift+K或选择 Git |推送Push 可从当前分支将更改推送到远程存储库。 “推送提交”对话框打开。在这里您可以看到所有要推送的提交以及所有受影响的文件。在推送更改之前，您可以看到每个文件的差异。为此，请右键单击文件并选择“显示差异”或按 Ctrl+D。</p>
</li>
<li>
<p>单击“推送Push”。</p>
<blockquote>
<p>要恢复推送的提交，请在 Git 工具窗口Alt+9的“日志”选项卡上右键单击该提交，然后选择“恢复提交”。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/undo-changes.html#revert-commit">详情</a></p>
</blockquote>
<blockquote>
<p>要撤消最新未推送的提交，请在 Git 工具窗口的日志选项卡Alt+9上右键单击它，然后选择“撤消提交”。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/undo-changes.html#revert-last-commit">详情</a></p>
</blockquote>
</li>
</ol>
<h4 id="选择性提交">选择性提交</h4>
<p>此操作允许您将选定提交的更改从一个分支应用到另一分支。</p>
<ol>
<li>
<p>在 master 分支中，进行您要挑选的更改。提交 Ctrl+K 并推送 Ctrl+Shift+K 应用此更改。</p>
</li>
<li>
<p>切换到 new_feature 分支。</p>
</li>
<li>
<p>在底部 Git 工具窗口 Alt+9 中，打开“日志Log”选项卡。</p>
</li>
<li>
<p>在“分支”列表中，选择 master 。</p>
</li>
<li>
<p>选择您的最后一次提交并单击窗口顶部右侧的小樱桃图标“cherry-pick”。</p>
</li>
<li>
<p>通过在打开的对话框中按“Accept Theirs”来解决冲突。这意味着我们通过精心挑选的提交中的更改来覆盖 main.cpp 文件中的代码。</p>
<blockquote>
<p>如果没有出现冲突，cherry-pick选择将自动提交，您只需推送更改即可。</p>
</blockquote>
</li>
<li>
<p>从打开的“提交更改Commit Changes”对话框中提交更改并推送它们 Ctrl+Shift+K。</p>
</li>
</ol>
<h3 id="关联远程仓库">关联远程仓库</h3>
<p>为了使您的项目可供其他贡献者使用，您需要将其发布到远程存储库，例如 <a target="_blank" rel="noopener" href="http://github.com">github.com</a>。 CLion 提供与 GitHub 的集成，允许您<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/manage-projects-hosted-on-github.html">管理 GitHub 上托管的项目</a>、<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/fork-github-projects.html#fork">fork外部存储库</a>、<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/work-with-github-pull-requests.html#apply-pull-request-changes">管理拉取pull请求</a>以及从 IDE 执行其他 GitHub 操作。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/github.html">详细教程</a></p>
<ol>
<li>
<p>在主菜单中，转至 VCS |在 GitHub 上分享项目。</p>
</li>
<li>
<p>在打开的对话框中，输入您的 GitHub 登录名和密码，然后单击登录。</p>
<blockquote>
<p>如果您尚未在 GitHub 上注册，请单击“注册 GitHub”以转至 <a target="_blank" rel="noopener" href="http://github.com">github.com</a> 并在那里创建一个新帐户。</p>
</blockquote>
<blockquote>
<p>您可以更改 GitHub 帐户或在“首选项”|“添加新帐户”中添加新帐户。版本控制 | GitHub。请参阅管理多个 GitHub 帐户中的更多信息。</p>
</blockquote>
</li>
<li>
<p>如果您为 GitHub 启用了双因素身份验证，则会出现对话框，输入代码并单击“确定”。</p>
</li>
<li>
<p>在打开的对话框中，您可以更改存储库名称（默认情况下，它与项目名称相同）、远程名称（默认情况下为 origin）、选择存储库类型（公共或私有），然后添加如果需要一些描述。</p>
</li>
<li>
<p>单击共享。项目成功发布到GitHub后，会出现通知。</p>
</li>
<li>
<p>单击通知中的链接以打开 GitHub 上的存储库。</p>
</li>
</ol>
<blockquote>
<p>您可以在“Git 远程”对话框中编辑远程列表。要打开该对话框，请选择 Git |管理远程。</p>
</blockquote>
<h3 id="创建一个新分支">创建一个新分支</h3>
<p>例如，当您正在开发新功能并且不希望更改在测试之前进入主（主）分支时，您可能需要创建一个单独的分支。</p>
<ol>
<li>
<p>按Ctrl+T拉取pull当前分支的最新版本。</p>
</li>
<li>
<p>在底部状态栏右侧，您可以看到当前分支 - master 。单击它打开 Git 分支菜单。</p>
</li>
<li>
<p>从 Git 分支菜单中，选择新建分支。</p>
</li>
<li>
<p>在打开的对话框中，指定分支名称，例如 new_feature ，然后选中“签出分支”复选框以立即切换到新分支。</p>
<blockquote>
<p>如果当前分支中有一些未版本化的更改，则需要在切换到另一个分支之前提交commit、还原revert或搁置shelve它们。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/manage-branches.html#switch-branches">教程</a></p>
</blockquote>
</li>
<li>
<p>现在您已切换到新创建的分支。</p>
</li>
<li>
<p>将对应的分支添加到远程仓库。为此，请在 Git 分支菜单中选择本地分支Local Branches-当前分支名称，然后单击 推送Push。</p>
</li>
<li>
<p>在打开的对话框中，单击“推送Push”。新分支将被添加到远程存储库，并将出现在 Git 分支菜单的 远程分支Remote Branches 列表中。</p>
</li>
</ol>
<blockquote>
<p>如果对一个分支内容进行了修改，没有进行提交就签出，CLion会提示选择“强制签出”、“智能签出”和“不签出”。</p>
</blockquote>
<h3 id="查看更改">查看更改</h3>
<ol>
<li>
<p>按Ctrl+T拉取pull当前分支的最新版本。</p>
</li>
<li>
<p>在工程中添加新文件，例如<code>subfunc.cpp</code>，并修改<code>main.cpp</code>文件。</p>
<blockquote>
<p>在项目工具窗口和编辑器选项卡中，CLion 对文件应用不同的颜色：蓝色表示已修改，绿色表示新添加。此外，在修改文件的装订线区域中，彩色更改标记出现在修改行旁边。</p>
</blockquote>
</li>
<li>
<p>您可以单击装订线标记来查看详细信息。单击“显示行的差异”图标以在单独的窗口中查看差异。</p>
</li>
<li>
<p>转到提交工具窗口Alt+0，立即预览所有更改。双击文件以在编辑器中打开差异视图。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/investigate-changes.html">详细教程</a></p>
</li>
</ol>
<h3 id="合并分支并解决冲突">合并分支并解决冲突</h3>
<p>有多种方法可以将更改从一个分支应用到另一个分支，例如合并和重新调整分支、挑选提交、应用单独的更改或文件。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/apply-changes-from-one-branch-to-another.html">详情</a></p>
<p>如何合并两个分支和择优提交：</p>
<ol>
<li>
<p>在“分支Branches”弹出窗口（主菜单 Git | 分支Branches）或 Git 工具窗口的“分支Branches”窗格中，选择要将要合并到的目标分支，然后从上下文菜单中选择“签出Checkout”以切换到该分支。</p>
</li>
<li>
<p>执行以下操作之一：</p>
<ul>
<li>
<p>如果不需要指定合并选项，请选择要合并到当前分支的分支，然后从子菜单中选择“合并到当前”。从底部右侧 Git Branches 菜单中，选择 new_feature 并单击 Merge into Current。</p>
</li>
<li>
<p>如果需要指定合并选项，请从主菜单中选择 VCS Git |合并更改以打开“合并”对话框。选择要合并到当前分支的分支，单击“修改选项Modify options”并从以下选项中进行选择：</p>
<ul>
<li><code>--no-ff</code>（推荐） ：在所有情况下都会创建合并提交，即使可以将合并解析为快进。<a href="#Git%E5%90%88%E5%B9%B6%E6%97%B6%60--no-ff%60%E7%9A%84%E4%BD%9C%E7%94%A8">Git合并时<code>--no-ff</code>的作用</a></li>
<li><code>--ff-only</code> ：仅当可以快进时才会解决合并。</li>
<li><code>--squash</code> ：将在当前分支之上创建包含所有拉取更改的单个提交。</li>
<li><code>-m</code> ：您将能够编辑合并提交的消息。</li>
<li><code>--no-commit</code> ：将执行合并，但不会创建合并提交，以便您可以在提交之前检查合并的结果。</li>
</ul>
<p>单击合并。</p>
</li>
</ul>
</li>
<li>
<p>如果你的工作树是干净的（这意味着你没有未提交的更改），并且你的功能分支和目标分支之间没有发生冲突，Git 将合并这两个分支，并且合并提交将出现在 Git 工具的 Log 选项卡中窗口 Alt+9 ：</p>
</li>
<li>
<p>由于我们在不同分支中对同一文件进行了更改，因此会出现“冲突”对话框。</p>
</li>
<li>
<p>在“冲突”对话框中，您有多个选项来解决冲突：</p>
<ul>
<li>Accept Yours：保留在当前分支中所做的更改。</li>
<li>Accept Theirs：应用要合并到当前分支的更改。</li>
<li>Merge：在专用对话框中手动解决冲突。</li>
</ul>
</li>
<li>
<p>单击合并Merge。 “合并修订Merge Revisions”对话框打开。</p>
</li>
<li>
<p>在此对话框中，您可以通过单击 the Apply changes from the left / the Apply changes from the right 接受更改，通过单击“拒绝更改”图标拒绝更改，然后在结果窗格中键入代码。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/resolve-conflicts.html">详情</a></p>
<blockquote>
<p>语法错误在“合并修订”窗口中突出显示。</p>
</blockquote>
</li>
<li>
<p>解决冲突，然后单击“应用”。</p>
</li>
<li>
<p>通过按 Ctrl+Shift+K或选择 Git | Push 将更改从当前分支推送到远程存储库。</p>
</li>
<li>
<p>您可以按Alt+9在底部 Git 工具窗口的 Log 选项卡中看到所有分支中的提交。从这里，您还可以恢复提交、从一个分支到另一个分支选择更改等等。<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/log-tab.html">详情</a></p>
</li>
</ol>
<h3 id="查看历史记录">查看历史记录</h3>
<p><a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/investigate-changes.html">详情</a></p>
<ul>
<li>在编辑器或项目工具窗口中右键单击该文件Alt+1并选择 Git |显示历史。 Git 工具窗口的历史记录选项卡打开。在此选项卡上，您可以查看影响该文件的所有提交，并找出您感兴趣的更改添加到哪个提交中</li>
<li>在这里，您可以查看影响您感兴趣的代码选择的所有提交。在编辑器中，选择要查看其历史记录的代码片段，右键单击所选内容，然后选择 Git |显示选择历史记录。选择历史记录窗口将打开。</li>
</ul>
<h2 id="git插件">git插件</h2>
<ul>
<li>GitToolBox：通过附加功能扩展Git，比如行后显示提交历史。设置-版本控制-GitToolBox</li>
<li>Git Commit Message Helper：标准化提交信息。设置-其它设置-GitCommitMessageHelper</li>
</ul>
<h1 id="参考链接">参考链接</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/103391101">个人博客第3篇——绑定GitHub并提交文件</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u_hcy2000/article/details/123052677">关于在ubuntu中git clone超时的问题</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/66973794">史上最简单的 GitHub 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30044692">Git使用教程,最详细，最傻瓜，最浅显，真正手把手教</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tocy/p/git-stash-reference.html">git-stash用法小结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-tutorial.html">Git 教程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单</a></li>
<li><a target="_blank" rel="noopener" href="https://geek-docs.com/git/git-questions/107_git_how_to_move_local_git_repo_from_one_hdd_to_another_hdd.html">Git 如何将本地Git仓库从一块硬盘移动到另一块硬盘</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/389462060/answer/1169524474">git如果不与任何账户绑定的话是不是只能用来管理本地的文件夹而不能上传任何东西？</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hjc_042043/article/details/135965334">有三种方法可以实现忽略Git中不想提交的文件</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/chinese/news/gitignore-file-how-to-ignore-files-and-folders-in-git/">.gitignore 文件——如何在 Git 中忽略文件和文件夹</a></li>
<li><a target="_blank" rel="noopener" href="https://geek-docs.com/git/git-questions/148_git_how_to_ignore_everything_in_a_directory_except_one_file.html">Git 如何忽略目录中的所有文件，但保留一个文件</a></li>
<li><a target="_blank" rel="noopener" href="https://ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hzf0701/article/details/134367234">Git Commit 之道：规范化 Commit Message 写作指南</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40780243/article/details/108900691">git commit 提交信息规范入门(配合vscode)</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1492295">结合企业实践来规范你的Git commit（含插件使用指南）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anly95/p/13163384.html">git commit 代码提交规范</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/soyxiaobi/p/10555400.html">git commit -m 提交的内容换行</a></li>
<li><a target="_blank" rel="noopener" href="https://deepinout.com/git/git-questions/237_git_add_line_break_to_git_commit_m_from_the_command_line.html">Git 如何从命令行中给’git commit -m’添加换行符</a></li>
<li><a target="_blank" rel="noopener" href="https://geek-docs.com/git/git-questions/237_git_add_line_break_to_git_commit_m_from_the_command_line.html">Git 如何在命令行中给 ‘git commit -m’ 添加换行符</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zombres/article/details/82179122">Git 合并时 --no-ff 的作用</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@lordmoma/so-you-think-you-know-git-673f9c4b0792">So You Think You Know Git</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/clion/apply-changes-from-one-branch-to-another.html">Merge, rebase, or cherry-pick to apply changes</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/124718643">详述 Git 的 rebase 命令使用方法</a></li>
<li><a target="_blank" rel="noopener" href="https://geek-docs.com/git/git-questions/152_tk_1704600594.html">Git Clone –recursive 的详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevin-ying/p/14329768.html">大厂git分支管理规范：gitflow规范指南</a></li>
<li><a target="_blank" rel="noopener" href="https://geek-docs.com/git/git-questions/579_git_git_pull_vs_fetchpull.html">Git 两个常用命令：pull和fetch的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://geek-docs.com/git/git-questions/1646_git_how_to_gitignore_files_recursively.html">Git如何递归地忽略文件</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" class="category-chain-item">技术分享</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Git的配置与使用</div>
      <div>http://zeyulong.com/posts/5b8fd703/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>龙泽雨</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/874d7da/" title="Latex的语法和使用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Latex的语法和使用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/35f6a63b/" title="evo工具的安装与使用">
                        <span class="hidden-mobile">evo工具的安装与使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://www.zeyulong.cn/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10,"reaction":true,"locale":{"placeholder":"花径不曾缘客扫，蓬门今始为君开。"}},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/custom/RunTime/RunTime.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/custom/live2d/live2d-widget/autoload.js"></script>
<script src="/custom/live2d/jquery.min.js"></script>
<script src="/custom/LabelPage/LabelPage.js"></script>
<script src="/custom/LoadingBar/pace.min.js"></script>
<script src="/custom/ReadingProgress/ReadingProgress.js"></script>
<script src="/custom/typing-effect/typing-effect.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  <canvas
    class="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script type="text/javascript" src="/custom/fireworks/anime.min.js"></script> 
<script type="text/javascript" src="/custom/fireworks/fireworks.js"></script>

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>



<!DOCTYPE html>
<html lang="zh-CN" >



<head><!-- hexo injector head_begin start --><progress id="content_progress" value="0"></progress><!-- hexo injector head_begin end -->
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/theme/TamakoAvatar-new-zip.png">
  <link rel="icon" href="/img/theme/TamakoAvatar-new-zip.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#000000">
  <meta name="author" content="龙泽雨">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文主要分享了自己在使用Linux和Windows系统过程中常用的命令及快捷键。">
<meta property="og:type" content="article">
<meta property="og:title" content="系统常用命令及快捷键">
<meta property="og:url" content="http://zeyulong.com/posts/a8aab215/index.html">
<meta property="og:site_name" content="龙泽雨的博客">
<meta property="og:description" content="本文主要分享了自己在使用Linux和Windows系统过程中常用的命令及快捷键。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-03-05T14:33:19.000Z">
<meta property="article:modified_time" content="2025-07-04T07:46:08.171Z">
<meta property="article:author" content="龙泽雨">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>系统常用命令及快捷键 - 龙泽雨的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  



  
<link rel="stylesheet" href="/custom/Markdown/macpanel.css">
<link rel="stylesheet" href="/custom/Fonts/CodeFont.css">
<link rel="stylesheet" href="/custom/Fonts/inlinecode-bg-color.css">
<link rel="stylesheet" href="/custom/LoadingBar/pace-theme-corner-indicator.css">
<link rel="stylesheet" href="/custom/ReadingProgress/ReadingProgress.css">
<link rel="stylesheet" href="/custom/SelectBackgroundColor/SelectBackgroundColor.css">
<link rel="stylesheet" href="/custom/waline/gif.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zeyulong.com","root":"/","version":"1.9.7","typing":{"enable":false,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"8gUBTaCjmaSbnf4genwggan3-MdYXbMMI","app_key":"2WRxjgxRXIWRBo8EA4205Wfm","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start --><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200;300;400;500;600;700;900&display=swap" rel="stylesheet"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hello, world!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/theme/GirlWithCat-cut.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">系统常用命令及快捷键</span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        龙泽雨
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-05 22:33" pubdate>
          2024年3月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          183 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">系统常用命令及快捷键</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年7月4日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>本文主要分享了自己在使用Linux和Windows系统过程中常用的命令及快捷键。</p>
<span id="more"></span>
<blockquote>
<p>注意中文<code>—</code>和英文字符<code>-</code></p>
</blockquote>
<h1 id="Linux">Linux</h1>
<blockquote>
<p>Win = Super</p>
</blockquote>
<h2 id="快捷键">快捷键</h2>
<h3 id="一般">一般</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Win+L</td>
<td style="text-align:center">锁屏</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+T</td>
<td style="text-align:center">新建终端</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+A（自定）</td>
<td style="text-align:center">flameshot 截图</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+F（自定）</td>
<td style="text-align:center">fsearch 搜索文件</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+N</td>
<td style="text-align:center">新建文件夹</td>
</tr>
<tr>
<td style="text-align:center">Win+I（自定义）</td>
<td style="text-align:center">打开设置中心</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+L</td>
<td style="text-align:center">全选文件夹路径</td>
</tr>
<tr>
<td style="text-align:center">F2</td>
<td style="text-align:center">文件（夹）重命名</td>
</tr>
<tr>
<td style="text-align:center">Win</td>
<td style="text-align:center">活动大纲</td>
</tr>
<tr>
<td style="text-align:center">Win+Tab/Alt+Tab</td>
<td style="text-align:center">切换应用程序</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Alt+上/下箭头，点击桌面左上角的“Activities”</td>
<td style="text-align:center">切换工作区（同一屏幕的全部内容）</td>
</tr>
<tr>
<td style="text-align:center">Alt+Enter</td>
<td style="text-align:center">查看选择文件/文件夹的属性，代替单击右键选择属性</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+1/2</td>
<td style="text-align:center">改变文件夹视图查看方式，图标视图/列表视图</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+H</td>
<td style="text-align:center">显示隐藏文件</td>
</tr>
<tr>
<td style="text-align:center">双击Ctrl（自定）</td>
<td style="text-align:center">打开uTools</td>
</tr>
<tr>
<td style="text-align:center">启动位于任务栏的程序</td>
<td style="text-align:center">Win + 数字键</td>
</tr>
</tbody>
</table>
<h3 id="窗口">窗口</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Win+E（自定义）</td>
<td style="text-align:center">新建文件夹窗口</td>
</tr>
<tr>
<td style="text-align:center">win+H</td>
<td style="text-align:center">隐藏窗口</td>
</tr>
<tr>
<td style="text-align:center">Win+D</td>
<td style="text-align:center">隐藏或显示全部应用窗口</td>
</tr>
<tr>
<td style="text-align:center">Win+A</td>
<td style="text-align:center">显示应用程序菜单</td>
</tr>
<tr>
<td style="text-align:center">Super+箭头</td>
<td style="text-align:center">移动窗口位置（左/右：贴左/右；上：最大化；下：恢复）</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+W</td>
<td style="text-align:center">关闭标签页</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Q/Alt+F4</td>
<td style="text-align:center">(强制）关闭应用程序（窗口）。ALT+F4是基于任务管理器连接结束进程项，CTRL+Q只是关闭的快捷键</td>
</tr>
<tr>
<td style="text-align:center">Alt+空格（自定）</td>
<td style="text-align:center">激活窗口菜单（内含置顶选项，也适用于没有系统标题栏的应用）</td>
</tr>
<tr>
<td style="text-align:center">Win+Shift+向上/下翻页</td>
<td style="text-align:center">将窗口上/下移一个工作区</td>
</tr>
<tr>
<td style="text-align:center">Win+Shift+上/下/左/右箭头</td>
<td style="text-align:center">将窗口上/下/左/右移一个显示器</td>
</tr>
<tr>
<td style="text-align:center">Alt+F7（自定义）</td>
<td style="text-align:center">使用键盘方向键移动窗口，按住Shift键快速贴边，按Enter键确认</td>
</tr>
</tbody>
</table>
<h3 id="目录">目录</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Backspace</td>
<td style="text-align:center">返回上一级目录</td>
</tr>
<tr>
<td style="text-align:center">Alt+左箭头</td>
<td style="text-align:center">回退（搭配Backspace回到下一级目录）</td>
</tr>
<tr>
<td style="text-align:center">Alt+右箭头</td>
<td style="text-align:center">前进（只能响应回退操作）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>打开文件夹之后，按backspace删除键就可以返回上一级；或者Alt+←也是可以返回上一级，用Alt+←返回上一级后，按Alt+→键就可以倒退回去一级。</p>
</blockquote>
<h2 id="鼠标">鼠标</h2>
<ol>
<li>直接拖拉在最大化时的窗口标题可以还原窗口大小，再拖放回去就最大化。</li>
<li>在音量控制处用鼠标滚轮滚动可以直接调整音量，在任务栏中滚动滚轮可以切换任务栏，工作区则切换工作区。</li>
<li>工作区里的小窗口可以在不同工作区内拖拉，即移动到另一个工作区的功能。</li>
<li>按住 <code>Shift</code> 拖动窗口可以吸附上下边缘的移动。</li>
<li>水平滚动文件，请在按住 <code>Shift</code> 的同时转动鼠标滚轮。</li>
<li>双击选中词，三击选中整句。</li>
<li>按住Alt，鼠标可以选中带链接的内容（而不打开链接）。</li>
<li>按住Shift，鼠标在开头和结尾点击，可以选中全文（不用拖动了）。</li>
<li>拖动选中可直接完成复制粘贴的操作（对于某些禁止复制粘贴的网站）。</li>
<li>在Win11，按住Shift，点击鼠标右键，呼出旧版菜单。</li>
<li>鼠标中间有快捷关闭的功能。</li>
</ol>
<h2 id="路径">路径</h2>
<ol>
<li>
<p>对于在<code>.zshrc</code>等文件中使用<code>export</code>命令时，举例说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:/new_path&quot;</span><br><span class="hljs-comment"># 1. 路径之间用英文:分隔，中间不需要加空格。</span><br><span class="hljs-comment"># 2. 加双引号可以避免潜在的解析错误（空格、特殊字符）。</span><br><span class="hljs-comment"># 3. $PATH放在前面，避免新增路径覆盖掉之前定义的路径，减少潜在的冲突。 </span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>系统查找命令时按照冒号分割顺序从前向后依次查找。</p>
</blockquote>
<p>配置路径的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo updatedb  <span class="hljs-comment"># 更新数据库</span><br><br>sudo gedit ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br>sudo gedit ~/.zshrc<br><span class="hljs-built_in">source</span> ~/.zshrc<br><br>sudo gedit /etc/profile  <span class="hljs-comment"># 此文件涉及系统的环境，即环境变量相关。这里修改会对所有用户起作用。</span><br><span class="hljs-comment"># 不能对zsh直接生效？需要在命令行里运行一遍source ~/.zshrc才能生效。</span><br><span class="hljs-built_in">source</span> /etc/profile  <span class="hljs-comment"># 让环境变量生效</span><br><br>sudo gedit /etc/ld.so.conf.d/opencv.conf<br>sudo ldconfig  <span class="hljs-comment"># 运行配置</span><br><br>sudo gedit /etc/ld.so.conf<br>sudo ldconfig  <span class="hljs-comment"># 运行配置</span><br><br>sudo gedit /etc/bash.bashrc<br><span class="hljs-built_in">source</span> /etc/bash.bashrc<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Ubuntu快捷方式图标的存放位置：</p>
<ul>
<li><code>/usr/share/applications</code></li>
<li><code>/usr/share/icons/Mojave-CT-Night/mimes/scalable</code></li>
</ul>
</li>
<li>
<p>打开回收站：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.local/share/Trash/files<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>wine软件安装路径：<code>/home/lll25655/.wine/drive_c/'Program Files (x86)'</code></p>
</li>
<li>
<p>打开eDiary：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wine /home/lll25655/.wine/drive_c/<span class="hljs-string">&#x27;Program Files (x86)&#x27;</span>/eDiary-4.2.2-win64/eDiary.exe<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>第三方库库默认安装路径</p>
<ol>
<li>
<p><code>/usr/include</code></p>
</li>
<li>
<p><code>/usr/local/include</code></p>
</li>
</ol>
</li>
<li>
<p>字体安装路径：<code>/usr/share/fonts</code></p>
</li>
</ol>
<h2 id="命令">命令</h2>
<h3 id="软件、库的安装、卸载和升级">软件、库的安装、卸载和升级</h3>
<h4 id="常用命令">常用命令</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>sudo apt update	<span class="hljs-comment"># 先更新软件包列表，检查可用的软件包更新</span><br><span class="hljs-comment"># 查看可选的安装版本</span><br>apt-cache search exact_package_name  <span class="hljs-comment"># 你可以使用一个正则表达式来搜索本地 APT 缓存中的包。</span><br>apt-cache policy exact_package_name  <span class="hljs-comment"># 如果你指定了软件包的名称，它将显示该软件包是否已经安装，在哪个版本的仓库中可用，以及它的优先级。</span><br>sudo apt install exact_package_name[=xxx]	<span class="hljs-comment"># 安装软件，例如：sudo apt install libc6-dev=2.27-3ubuntu1.6</span><br><br><span class="hljs-comment"># 卸载（不知名的软件）</span><br>apt list --installed | grep -i possible_package_name  <span class="hljs-comment"># 模糊搜索</span><br>sudo apt remove exact_package_name  <span class="hljs-comment"># 卸载软件</span><br>sudo apt-get purge exact_package_name  <span class="hljs-comment"># 清除配置</span><br><br><span class="hljs-comment"># 升级</span><br><span class="hljs-comment"># apt 可以看作 apt-get 和 apt-cache 命令的子集, 可以为包管理提供必要的命令选项。apt-get 虽然没被弃用，但作为普通用户，还是应该首先使用 apt。</span><br>sudo apt update  <span class="hljs-comment"># 更新软件包列表，检查可用的软件包更新</span><br>apt list --upgradable  <span class="hljs-comment"># 查看可用安装</span><br>sudo apt upgrade  <span class="hljs-comment"># 安装可用的软件包更新</span><br>sudo apt install exact_package_name  <span class="hljs-comment"># 直接升级特定的包</span><br></code></pre></td></tr></table></figure>
<p>优先级：</p>
<ul>
<li><strong>&lt; 0</strong>：永远不会安装，</li>
<li><strong>1..99</strong>：仅当尚未安装其他版本的软件包时才会安装，</li>
<li><strong>100..499</strong>：仅当其他发行版中没有安装或提供其他更新版本时才会安装，</li>
<li><strong>500....989</strong>：仅当目标发行版中没有安装或没有更新的版本时才会安装，</li>
<li><strong>990..1000</strong>：将安装，除非安装的版本较新，</li>
<li><strong>&gt; 1000</strong>：将始终安装，即使它强制 APT 降级到旧版本。</li>
</ul>
<p>默认情况下，每个已安装的软件包版本的优先级为 100，未安装的软件包的优先级为 500。同一软件包可能有多个不同优先级的版本。APT 会安装优先级较高的版本，除非安装的版本较新。</p>
<h4 id="deb">deb</h4>
<h5 id="安装">安装</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg -i xxx.deb<br></code></pre></td></tr></table></figure>
<h5 id="安装路径">安装路径</h5>
<p>在 Ubuntu 下，使用 <code>*.deb</code> 包安装的软件，其<strong>主要文件会分散安装在系统的标准目录</strong>，而不是集中在某一个“专属”文件夹。具体来说：</p>
<ul>
<li>可执行文件（程序主文件）
<ul>
<li>通常安装在 <code>/usr/bin/</code>、<code>/usr/sbin/</code>、<code>/bin/</code>、<code>/sbin/</code> 等目录。</li>
<li>例如：<code>/usr/bin/vim</code>、<code>/usr/bin/git</code></li>
</ul>
</li>
<li>配置文件
<ul>
<li>一般安装在 <code>/etc/</code> 目录下的子目录。</li>
<li>例如：<code>/etc/nginx/</code>、<code>/etc/mysql/</code></li>
</ul>
</li>
<li>库文件
<ul>
<li>通常安装在 <code>/usr/lib/</code> 或 <code>/usr/lib64/</code>。</li>
<li>例如：<code>/usr/lib/libreoffice/</code></li>
</ul>
</li>
<li>共享数据文件
<ul>
<li>通常安装在 <code>/usr/share/</code> 下。</li>
<li>例如：<code>/usr/share/doc/</code>（文档）、<code>/usr/share/applications/</code>（桌面快捷方式）</li>
</ul>
</li>
<li>日志文件
<ul>
<li>如果有日志，通常在 <code>/var/log/</code> 下。</li>
<li>例如：<code>/var/log/nginx/</code></li>
</ul>
</li>
<li>卸载脚本、服务文件等
<ul>
<li>可能会分布在 <code>/etc/init.d/</code>、<code>/lib/systemd/system/</code> 等与服务相关的位置。</li>
</ul>
</li>
</ul>
<h5 id="如何查看某个-deb-包都装了哪些文件？">如何查看某个 .deb 包都装了哪些文件？</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -L package_name<br><span class="hljs-comment"># 或者</span><br>dpkg-deb -c xxx.deb<br></code></pre></td></tr></table></figure>
<h5 id="卸载使用deb安装的软件">卸载使用deb安装的软件</h5>
<blockquote>
<p>操作前确保备份重要数据，以防误删。</p>
</blockquote>
<ol>
<li>
<p>卸载软件包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># apt list --installed | grep -i possible_package_name  # 模糊搜索</span><br>sudo apt remove package_name<br><span class="hljs-comment"># or</span><br>sudo dpkg -r package_name<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>彻底卸载并删除配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt purge package_name<br><span class="hljs-comment"># or</span><br>sudo dpkg --purge package_name<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>（可选）自动清理无用依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt autoremove<br>sudo apt autoclean<br></code></pre></td></tr></table></figure>
<blockquote>
<p>该操作好像挺危险的，说不定会误删。</p>
</blockquote>
</li>
<li>
<p>删除用户数据和用户信息：</p>
<p>有的软件在用户目录下会有隐藏文件夹或配置（如 <code>~/.config/package_name</code>、<code>~/.package_name</code> 等），你可以<strong>手动删除这些目录</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf ~/.config/package_name<br><span class="hljs-built_in">rm</span> -rf ~/.package_name<br><span class="hljs-built_in">rm</span> -rf ~/package_name<br></code></pre></td></tr></table></figure>
<p>如果软件为所有用户创建了专用的系统用户（比如 <code>/home/someuser</code> 或 <code>/var/lib/package_name</code>），你还可以：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo deluser someuser<br>sudo <span class="hljs-built_in">rm</span> -rf /home/someuser<br></code></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">rm</span> -rf /var/lib/package_name<br>sudo <span class="hljs-built_in">rm</span> -rf /etc/package_name<br></code></pre></td></tr></table></figure>
<blockquote>
<p>软件在以上各文件夹内的命名不一定就是<code>package_name</code>，可能有大小写的区别，可能是缩写，等等。最好亲自去看看各文件夹内的内容来筛选和删除。</p>
</blockquote>
</li>
<li>
<p>查找和删除残余文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo find / -name <span class="hljs-string">&quot;*package_name*&quot;</span><br></code></pre></td></tr></table></figure>
<p>删除搜索出的软件文件。</p>
</li>
<li>
<p>完成。</p>
</li>
</ol>
<h3 id="查找查看">查找查看</h3>
<h4 id="辅助搭配">辅助搭配</h4>
<blockquote>
<p>Linux <code>grep</code> (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l /usr/local | grep cuda  <span class="hljs-comment"># 查询`/usr/local`路径下的软链接，且要求包括`cuda`字符串。</span><br></code></pre></td></tr></table></figure>
<p><strong>常用选项：</strong>：</p>
<ul>
<li><code>-i</code>：忽略大小写进行匹配。</li>
<li><code>-v</code>：反向查找，只打印不匹配的行。</li>
<li><code>-n</code>：显示匹配行的行号。</li>
<li><code>-r</code>：递归查找子目录中的文件。</li>
<li><code>-l</code>：只打印匹配的文件名。</li>
<li><code>-c</code>：只打印匹配的行数。</li>
</ul>
</blockquote>
<h4 id="当前终端">当前终端</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells  <span class="hljs-comment"># 查看系统安装了的shell</span><br><span class="hljs-comment"># /usr/bin/zsh为软链接，指向/bin/zsh。可能是为了系统兼容性。</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span>  <span class="hljs-comment"># 当前的shell。实际没显示成功，但是确实改成功了？</span><br><span class="hljs-comment"># 切换终端Shell</span><br>chsh -s /bin/bash<br>chsh -s /bin/zsh<br>chsh -s $(<span class="hljs-built_in">which</span> zsh)<br><span class="hljs-comment"># 或</span><br><span class="hljs-built_in">exec</span> bash  <span class="hljs-comment"># 将命令行从zsh切换为bash</span><br><span class="hljs-built_in">exec</span> zsh  <span class="hljs-comment"># 重新运行zsh命令行工具</span><br></code></pre></td></tr></table></figure>
<h4 id="环境变量">环境变量</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$CUDA_HOME</span><br></code></pre></td></tr></table></figure>
<h4 id="内存">内存</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">free -g  <span class="hljs-comment"># 以 GB 为单位，显示内存使用情况。</span><br><span class="hljs-comment"># -s  根据指定的间隔时间，持续显示内存使用情况。</span><br></code></pre></td></tr></table></figure>
<h4 id="文件系统和挂载点">文件系统和挂载点</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 推荐，可查看到交换空间</span><br><span class="hljs-built_in">cat</span> /etc/fstab<br><span class="hljs-comment"># 或，信息更全，有硬盘使用率等</span><br><span class="hljs-built_in">df</span> -hT<br></code></pre></td></tr></table></figure>
<h4 id="文件（夹）大小">文件（夹）大小</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看指定目录下的各文件（夹）大小</span><br><span class="hljs-comment"># du 命令需要在root权限下操作，或者在命令行前加sudo命令也可以。但排序是乱的，不好查看。</span><br><span class="hljs-comment"># 使用 sort 命令 的 -k 参数设置对第二列的值进行重排，也就是按照文件（夹）名进行排序</span><br>sudo <span class="hljs-built_in">du</span> -ah --max-depth=1 --exclude=./proc --exclude=./tmp --exclude=./lost+found --exclude=./media --exclude=./mnt --exclude=./run /path/to/your/folder/ | <span class="hljs-built_in">sort</span> -k 2<br><br><span class="hljs-comment"># 查看指定目录对应的磁盘空间大小</span><br><span class="hljs-built_in">df</span> -B G /path/to/your/folder/  <span class="hljs-comment"># 以GB为单位显示指定磁盘文件的使用情况。如果没有指定文件，则显示所有挂载的文件系统的磁盘使用情况。</span><br><span class="hljs-built_in">df</span> -B M /path/to/your/folder/  <span class="hljs-comment"># MB</span><br><span class="hljs-comment"># 加路径为当前路径所在的磁盘空间，不加路径为所有。</span><br><br><span class="hljs-comment"># 上述两个命令的常用参数：</span><br>-a或 -all 显示目录中个别文件的大小。<br>-h或 --human-readable 以K，M，G为单位，提高信息的可读性。<br>--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>-exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br><br>ll  <span class="hljs-comment"># 文件大小以字节为单位显示，并且在输出中的第 5 列。</span><br></code></pre></td></tr></table></figure>
<h4 id="文件（夹）修改时间">文件（夹）修改时间</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ll  <span class="hljs-comment"># ls -l</span><br></code></pre></td></tr></table></figure>
<h4 id="文件（夹）权限">文件（夹）权限</h4>
<p>在使用 <code>ls -l</code> 命令时，第一列的其余 9 个字符表示文件或目录的访问权限，分别对应三个字符一组的 <strong>rwx</strong> 权限。例如：</p>
<ul>
<li>r 表示读取权限</li>
<li>w 表示写入权限</li>
<li>x 表示执行权限</li>
<li>- 表示没有对应权限</li>
</ul>
<p>前三个字符表示所有者的权限，中间三个字符表示所属组的权限，后三个字符表示其他用户的权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-rw-r--r-- 1 user group 4096 Feb 21 12:00 file.txt<br></code></pre></td></tr></table></figure>
<p>表示文件名为<code>file.txt</code>的文件，所有者具有读写权限，所属组和其他用户只有读取权限。</p>
<h4 id="版本信息">版本信息</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Linux内核版本</span><br><span class="hljs-built_in">uname</span> -a  <span class="hljs-comment"># 系统架构x64（x86_64、amd64）</span><br><span class="hljs-comment"># 系统架构：x64（x86_64、amd64）、arm64（aarch64）、mips64（mips64el）</span><br><span class="hljs-comment"># cmake</span><br>cmake --version<br><span class="hljs-comment"># conda</span><br>conda --version<br><span class="hljs-comment"># CPU核心数</span><br><span class="hljs-built_in">nproc</span><br><span class="hljs-comment"># CPU占用</span><br>top<br><span class="hljs-comment"># CUDA</span><br><span class="hljs-built_in">ls</span> -l /usr/local | grep cuda  <span class="hljs-comment"># 检查是否安装了CUDA</span><br>nvcc -V  <span class="hljs-comment"># 查看自己安装的CUDA版本</span><br>lspci | grep -i nvidia  <span class="hljs-comment"># 检查系统是否有支持 CUDA 编程的 GPU</span><br><span class="hljs-comment"># cuDNN</span><br>apt show libcudnn8  <span class="hljs-comment"># 通过查询已安装的libcudnn8包来验证cuDNN的版本</span><br><span class="hljs-comment"># 查看版本（路径可能不一致，有一个命令有输出就行）</span><br><span class="hljs-built_in">cat</span> /usr/include/cudnn_version.h  <br><span class="hljs-built_in">cat</span> /usr/include/cudnn.h<br><span class="hljs-built_in">cat</span> /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2<br><span class="hljs-built_in">cat</span> /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2<br><span class="hljs-comment"># Eigen</span><br>/usr/include/eigen3  <span class="hljs-comment"># Eigen安装路径</span><br>/usr/include/eigen330  <span class="hljs-comment"># Eigen3.3.0安装路径</span><br>/usr/include/eigen340  <span class="hljs-comment"># Eigen3.4.0安装路径</span><br>gedit /usr/include/eigen3/Eigen/src/Core/util/Macros.h<br><span class="hljs-comment"># GLIBC_</span><br>ldd --version<br>strings /lib/x86_64-linux-gnu/libm.so.6 |grep GLIBC_  <span class="hljs-comment"># strings /lib64/libc.so.6 |grep GLIBC_</span><br>ll /lib/x86_64-linux-gnu/libm.so.6<br><span class="hljs-comment"># gcc</span><br>gcc -v<br><span class="hljs-comment"># java</span><br>java -version<br><span class="hljs-comment"># 内存</span><br>free<br><span class="hljs-comment"># NVIDIA</span><br>lspci | grep -i nvidia  <span class="hljs-comment"># 查看是否安装NVIDIA显卡</span><br>nvidia-smi  <span class="hljs-comment"># 查看显卡信息</span><br>watch -n 0.2 nvidia-smi  <span class="hljs-comment"># 每 0.2 秒刷新一次</span><br><span class="hljs-comment"># 显卡型号</span><br>lspci | grep -i nvidia<br><span class="hljs-comment"># Opencv</span><br>/usr/local  <span class="hljs-comment"># opencv3.1.0安装路径</span><br>/usr/local/opencv/opencv320  <span class="hljs-comment"># opencv3.2.0安装路径</span><br>/usr/local/opencv/opencv345  <span class="hljs-comment"># opencv3.4.5安装路径</span><br>pkg-config --modversion opencv  <span class="hljs-comment"># 查询版本</span><br>pkg-config --cflags opencv  <span class="hljs-comment"># 得到opencv的安装路径</span><br><span class="hljs-comment"># -&gt; -I/usr/local/include/opencv -I/usr/local/include</span><br>pkg-config --cflags opencv4  <span class="hljs-comment"># 附加：得到opencv4的安装路径</span><br><span class="hljs-comment"># openssl</span><br>openssl version -a<br><span class="hljs-comment"># Pangolin</span><br>find / -name pangolin<br><span class="hljs-comment"># protoc</span><br>protoc --version<br><span class="hljs-comment"># python</span><br><span class="hljs-built_in">which</span> python<br>ll /usr/bin/python<br>python -V  <span class="hljs-comment"># python --version</span><br>sudo update-alternatives --config python<br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 1<br>sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 2<br><span class="hljs-comment"># Qt5.9.9</span><br>qmake -v<br><span class="hljs-comment"># ROS</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$ROS_PACKAGE_PATH</span><br></code></pre></td></tr></table></figure>
<h4 id="用户手册">用户手册</h4>
<p>Linux man 命令是 &quot;manual&quot; 单词的缩写，用于查看各种命令、函数和配置文件的手册页面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">man [选项] [节号] 命令/主题<br></code></pre></td></tr></table></figure>
<h4 id="查找文件">查找文件</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo updatedb  <span class="hljs-comment"># 更新数据库</span><br><br><span class="hljs-comment"># find命令</span><br>find / -name httpd.conf  <span class="hljs-comment"># 在根目录下查找文件httpd.conf，表示在整个硬盘查找</span><br>find -name your-file-name  <span class="hljs-comment"># 在当前目录中搜索</span><br><span class="hljs-comment"># 可以使用通配符*来实现粗略匹配</span><br><span class="hljs-comment"># 可以逻辑运算符not(!)、and(-a)、or(-o) 一起使用以组成的复合条件进行文件查找</span><br>find / -name hello_world* 2&gt;/dev/null  <span class="hljs-comment"># 忽略错误信息输出</span><br><br><span class="hljs-comment"># locate命令</span><br>locate filename<br></code></pre></td></tr></table></figure>
<h4 id="目录列表">目录列表</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span>  <span class="hljs-comment"># 显示当前目录位置 </span><br><span class="hljs-built_in">ls</span><br>-a 显示所有文件及目录 ( 以. 开头的隐藏文件也会列出)<br>-l 以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等<br>-h：文件大小以K，M，G为单位，提高信息的可读性<br><span class="hljs-built_in">ls</span> /usr/bin/gcc*   <span class="hljs-comment"># 在/usr/bin目录下所有含有gcc前缀的文件</span><br><span class="hljs-comment">#此处使用 ll 命令更好（可以看到软链接）：</span><br>ll /usr/bin/gcc*<br></code></pre></td></tr></table></figure>
<h4 id="文件内容">文件内容</h4>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31267769/article/details/109336193">参考链接</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看整个文件</span><br><span class="hljs-built_in">cat</span> [filename]  <span class="hljs-comment"># cat /home/user/test.txt</span><br><br><span class="hljs-comment"># 查看开头几行</span><br><span class="hljs-built_in">head</span> -n [rows] [filename]  <span class="hljs-comment"># head -n 20 /home/user/test.txt</span><br><br><span class="hljs-comment"># 查看末尾几行</span><br><span class="hljs-built_in">tail</span> -n [rows] [filename]  <span class="hljs-comment"># tail -n 10 /home/user/test.txt</span><br><br><span class="hljs-comment"># 查看中间几行</span><br><span class="hljs-comment"># 方法一：</span><br><span class="hljs-built_in">cat</span> [filename]| <span class="hljs-built_in">head</span> -n [endRow] | <span class="hljs-built_in">tail</span> -n +[beginRow]<br><span class="hljs-comment"># 查看/home/user/test.txt的10~20行</span><br><span class="hljs-comment"># head -n 20 表示前20行</span><br><span class="hljs-comment"># tail -n 10 表示后10行</span><br><span class="hljs-comment"># tail -n +10 表示第10行之后的</span><br><span class="hljs-built_in">cat</span> /home/user/test.txt| <span class="hljs-built_in">head</span> -n 20 | <span class="hljs-built_in">tail</span> -n +10<br><span class="hljs-comment"># 方法二：</span><br>sed -n <span class="hljs-string">&#x27;[begin],[end]p&#x27;</span> [filename]<br>sed -n <span class="hljs-string">&#x27;10,20p&#x27;</span> /home/user/test.txt<br></code></pre></td></tr></table></figure>
<h4 id="查找过去编辑的文件">查找过去编辑的文件</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -mmin -10  <span class="hljs-comment"># 查找过去 10 分钟内编辑的所有文件</span><br></code></pre></td></tr></table></figure>
<h4 id="历史命令">历史命令</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span> 5  <span class="hljs-comment"># 这将显示您最近执行的五个命令，以便于快速调用和重新运行它们。</span><br><span class="hljs-comment"># 您可以使用感叹号 ( ! ) 后跟命令编号来快速重新执行历史记录中的任何命令。</span><br><span class="hljs-comment"># 例如，如果您想重新运行上面的mkdir newdir命令（命令号 125），您只需键入：</span><br>!125<br></code></pre></td></tr></table></figure>
<h3 id="文件新建、复制、移动、重命名和删除">文件新建、复制、移动、重命名和删除</h3>
<h4 id="基本">基本</h4>
<blockquote>
<p>处理（特别是包含众多小文件的）大文件夹推荐使用[rsync](# rsync)命令。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit ~/.bashrc	 <span class="hljs-comment"># 使用gedit打开文件</span><br><span class="hljs-built_in">touch</span> file1.txt  <span class="hljs-comment"># 新建文件</span><br><br><span class="hljs-built_in">mkdir</span> [-p] dirName  <span class="hljs-comment"># 创建目录。-p 确保目录名称存在，不存在的就建一个。</span><br><span class="hljs-built_in">mkdir</span> -p runoob2/test  <span class="hljs-comment"># 在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br><span class="hljs-built_in">mkdir</span> -p &#123;dev,<span class="hljs-built_in">test</span>,prod&#125;/&#123;backend,frontend&#125;  <span class="hljs-comment"># 使用大括号&#123;&#125;一次性创建多个目录</span><br><br><span class="hljs-comment"># 在指定的目录下，创建一个名为 LINK_NAME 的硬链接或符号链接，指向名为 TARGET 的文件或目录。</span><br><span class="hljs-built_in">ln</span> [OPTION]... [-T] TARGET LINK_NAME<br><br><span class="hljs-comment"># 复制文件或目录cp命令</span><br><span class="hljs-comment"># 示例</span><br><span class="hljs-built_in">cp</span> file.txt /path/to/destination/<br>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。<br>-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。<br>-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。<br>-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。<br>在使用 <span class="hljs-built_in">cp</span> 命令复制文件时，如果目标文件夹内存在同名文件，默认情况下，<span class="hljs-built_in">cp</span> 命令会覆盖目标文件夹中的同名文件。<br>如果你希望在复制文件时避免覆盖同名文件，可以使用 -n 选项（即 --no-clobber），这样如果目标文件夹内存在同名文件，<span class="hljs-built_in">cp</span> 命令将不会覆盖它们。<br><span class="hljs-comment"># 有斜杠，只复制内容；无斜杠，连目录一起复制。</span><br><span class="hljs-built_in">cp</span> -r /path/to/source_dir/ /path/to/destination/  <span class="hljs-comment"># 把 source_dir 里面的所有文件和子目录直接复制到 destination/ 目录下</span><br><span class="hljs-built_in">cp</span> -r /path/to/source_dir /path/to/destination/  <span class="hljs-comment"># 会把 source_dir 这个目录（连同它的内容）复制到 destination/ 目录下</span><br><br><span class="hljs-comment"># Linux `mv`（英文全拼：move file）命令用来为文件或目录改名、或将文件或目录移入其它位置</span><br><span class="hljs-comment"># 注意：需要先执行`Ctrl+H`显示隐藏文件命令，否则，隐藏文件以及隐藏文件夹不会被移动到新目录</span><br><span class="hljs-comment"># 将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="hljs-built_in">mv</span> source_file(文件) dest_file(文件)<br><span class="hljs-comment"># 将文件 source_file 移动到目标目录 dest_directory 中</span><br><span class="hljs-built_in">mv</span> source_file(文件) dest_directory(目录)<br><span class="hljs-comment"># 目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；</span><br><span class="hljs-comment"># 目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</span><br><span class="hljs-built_in">mv</span> source_directory(目录) dest_directory(目录)<br><span class="hljs-comment"># 出错</span><br><span class="hljs-built_in">mv</span> source_directory(目录) dest_file(文件)<br><br><span class="hljs-comment"># 删除文件和文件夹rm命令</span><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-built_in">test</span>/  <span class="hljs-comment"># 删除 test 文件夹，删除文件夹要加 -r 参数。末尾的斜杠只是明确指示 test 是一个目录，但对于 rm 命令来说，这没有实际影响。</span><br>-i 删除前逐一询问确认。<br>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。<br>-r 将目录及以下之档案亦逐一删除。<br><span class="hljs-comment"># 删除当前目录及其子目录中所有.json文件的bash命令：</span><br>find . -name <span class="hljs-string">&quot;*.json&quot;</span> -<span class="hljs-built_in">type</span> f -delete<br><span class="hljs-comment"># find：这是主命令，用于查找文件。</span><br><span class="hljs-comment"># .：这告诉find命令从当前目录开始搜索。</span><br><span class="hljs-comment"># -name &quot;*.json&quot;：这告诉find命令查找所有以.json结尾的文件。</span><br><span class="hljs-comment"># -type f：这告诉find命令只查找文件，不包括目录。</span><br><span class="hljs-comment"># -delete：这告诉find命令删除找到的所有文件。</span><br></code></pre></td></tr></table></figure>
<h4 id="rsync">rsync</h4>
<h5 id="基本语法">基本语法</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install rsync<br></code></pre></td></tr></table></figure>
<ul>
<li><code>-a</code>, <code>--archive</code>: 归档模式，表示以递归的方式传输文件，并保持所有文件属性不变</li>
<li><code>--delete</code>: 删除那些target中有而source没有的文件</li>
<li><code>--exclude</code>: 指定排除不进行同步的文件，比如<code>--exclude=&quot;*.iso&quot;</code>。</li>
<li><code>-h</code>: 以人类可读的格式输出。</li>
<li><code>--progress</code>: 显示进度</li>
<li><code>-v</code>: 详细输出模式</li>
</ul>
<h5 id="用法">用法</h5>
<blockquote>
<p><code>rsync</code>命令不仅可以传输文件夹，还可以传输单个文件。</p>
</blockquote>
<h6 id="复制-移动大文件夹">复制/移动大文件夹</h6>
<p>本机使用 rsync 命令时，可以作为<code>cp</code>和<code>mv</code>命令的替代方法，将源目录同步到目标目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -ahv --progress <span class="hljs-built_in">source</span>/ destination/  <span class="hljs-comment"># 把source文件夹的内容复制进destination文件夹</span><br>rsync -ahv --progress <span class="hljs-built_in">source</span> destination/  <span class="hljs-comment"># 把source文件夹复制进destination文件夹</span><br>rsync -ahv --progress source1/ source2/ destination/  <span class="hljs-comment"># source1、source2都会被同步到destination目录。</span><br></code></pre></td></tr></table></figure>
<h6 id="删除大文件夹">删除大文件夹</h6>
<p>在删除包含许多小文件的大文件夹时，可以考虑使用<code>rsync</code>命令，以提高删除速度。以下是具体步骤：</p>
<ol>
<li>使用<code>rsync</code>将文件夹同步为空目录，达到快速删除文件的效果。</li>
<li>删除空目录。</li>
</ol>
<p>具体命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> empty_dir/  <span class="hljs-comment"># 创建一个空目录</span><br>rsync -ahv --progress --delete empty_dir/ /path/to/your/folder/  <span class="hljs-comment"># 将目标文件夹同步为空目录，快速删除文件内容</span><br><span class="hljs-built_in">rmdir</span> /path/to/your/folder/  <span class="hljs-comment"># 删除同步后的空目录</span><br><span class="hljs-built_in">rmdir</span> empty_dir/  <span class="hljs-comment"># 删除创建的空目录</span><br></code></pre></td></tr></table></figure>
<p>请替换<code>/path/to/your/folder/</code>为你要删除的文件夹的实际路径。</p>
<h6 id="增量备份">增量备份</h6>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2020/08/rsync.html">参考链接</a></p>
<p>rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。</p>
<p>除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。</p>
<p>具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。</p>
<p><code>--link-dest</code>参数用来指定同步时的基准目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -a --delete --link-dest /compare/path /source/path /target/path<br></code></pre></td></tr></table></figure>
<p>上面命令中，<code>--link-dest</code>参数指定基准目录<code>/compare/path</code>，然后源目录<code>/source/path</code>跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录<code>/target/path</code>。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了。</p>
<p>下面是一个脚本示例，备份用户的主目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># A script to perform incremental backups using rsync</span><br><br><span class="hljs-built_in">set</span> -o errexit<br><span class="hljs-built_in">set</span> -o nounset<br><span class="hljs-built_in">set</span> -o pipefail<br><br><span class="hljs-built_in">readonly</span> SOURCE_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HOME&#125;</span>&quot;</span><br><span class="hljs-built_in">readonly</span> BACKUP_DIR=<span class="hljs-string">&quot;/mnt/data/backups&quot;</span><br><span class="hljs-built_in">readonly</span> DATETIME=<span class="hljs-string">&quot;<span class="hljs-subst">$(date &#x27;+%Y-%m-%d_%H:%M:%S&#x27;)</span>&quot;</span><br><span class="hljs-built_in">readonly</span> BACKUP_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>/<span class="hljs-variable">$&#123;DATETIME&#125;</span>&quot;</span><br><span class="hljs-built_in">readonly</span> LATEST_LINK=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>/latest&quot;</span><br><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_DIR&#125;</span>&quot;</span><br><br>rsync -av --delete \<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>/&quot;</span> \<br>  --link-dest <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span> \<br>  --exclude=<span class="hljs-string">&quot;.cache&quot;</span> \<br>  <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_PATH&#125;</span>&quot;</span><br><br><span class="hljs-built_in">rm</span> -rf <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span><br><span class="hljs-built_in">ln</span> -s <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BACKUP_PATH&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;LATEST_LINK&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>上面脚本中，每一次同步都会生成一个新目录<code>$&#123;BACKUP_DIR&#125;/$&#123;DATETIME&#125;</code>，并将软链接<code>$&#123;BACKUP_DIR&#125;/latest</code>指向这个目录。下一次备份时，就将<code>$&#123;BACKUP_DIR&#125;/latest</code>作为基准目录，生成新的备份目录。最后，再将软链接<code>$&#123;BACKUP_DIR&#125;/latest</code>指向新的备份目录。</p>
<h4 id="复制时排除部分文件（夹）">复制时排除部分文件（夹）</h4>
<p>示例：把某个文件夹（比如 <code>/path/to/source</code>）下的所有内容完整复制到一个新文件夹（比如 <code>/path/to/target</code>），但在复制过程中，排除掉所有叫 <code>build</code> 的文件夹（不管它们在什么层级）。</p>
<h5 id="推荐方法：用-rsync">推荐方法：用 rsync</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av --exclude=<span class="hljs-string">&#x27;build/&#x27;</span> /path/to/source/ /path/to/target/<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p><code>--exclude='build/'</code> ：会排除所有名为 <code>build</code> 的目录（在任何层级都会被排除）。</p>
<blockquote>
<ul>
<li><code>--exclude=build</code>：排除根目录下的 build 文件夹（只排除 source 根下的 build，不影响子目录里的 build）</li>
</ul>
</blockquote>
</li>
<li>
<p><code>/path/to/source/</code> 末尾的 <code>/</code> 表示复制“内容”，而不是把<code>source</code>文件夹本身也复制过去。</p>
</li>
<li>
<p>这样，<code>source</code>下所有内容（除了任何层级的<code>build</code>文件夹）都会被复制到<code>target</code>。</p>
</li>
</ul>
<h5 id="如果只能用-cp？">如果只能用 cp？</h5>
<p><code>cp</code> 的 <code>--exclude</code> 选项并不支持递归排除所有层级的某个名字，需要结合 <code>find</code> 和 <code>cpio</code> 或者 <code>rsync</code>。如果必须用纯 Bash，可以这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /path/to/source<br>find . -<span class="hljs-built_in">type</span> d -name build -prune -o -<span class="hljs-built_in">print</span> | cpio -pdm /path/to/target<br></code></pre></td></tr></table></figure>
<p>如果只需要排除根目录下的<code>build/</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">shopt</span> -s extglob dotglob  <span class="hljs-comment"># 开启扩展模式匹配，使得 shell 可以识别更多的模式匹配操作符</span><br><span class="hljs-built_in">cp</span> -r /path/to/source/!(build) /path/to/target/<br></code></pre></td></tr></table></figure>
<h4 id="mkcd">mkcd</h4>
<p>将<code>mkdir</code>和<code>cd</code>命令合并为一个<code>mkcd</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">mkcd</span></span>() &#123;<br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># or</span><br><span class="hljs-keyword">function</span> mkcd &#123;<br> <span class="hljs-keyword">if</span> [ ! -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Enter mkcd followed by a directory name&quot;</span><br> <span class="hljs-keyword">elif</span> [ -d <span class="hljs-variable">$1</span> ]; <span class="hljs-keyword">then</span><br> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;\`<span class="hljs-variable">$1</span>&#x27; already exists&quot;</span><br> <span class="hljs-keyword">else</span><br> <span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$1</span> &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$1</span><br> <span class="hljs-keyword">fi</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数接受一个参数（<code>$1</code>），首先使用<code>mkdir -p</code>命令创建一个目录，然后使用<code>cd</code>命令进入这个目录。<code>-p</code>选项可以确保如果目录已经存在，<code>mkdir</code>命令不会报错。</p>
<p>你可以将这个函数添加到你的bash配置文件（如<code>~/.bashrc</code>或<code>~/.bash_profile</code>）中，这样每次打开一个新的终端时，这个函数都会被定义。</p>
<p>使用这个函数的方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkcd new_directory<br></code></pre></td></tr></table></figure>
<p>这将创建一个名为<code>new_directory</code>的新目录，并立即进入这个目录。</p>
<h3 id="下载">下载</h3>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022301195#GeneratedCaptionsTabForHeroSec">wget 与 curl 命令详解</a></p>
<blockquote>
<p>测试网络连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping www.baidu.com<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="wget">wget</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install wget<br><br><span class="hljs-comment"># 下载单个文件</span><br>wget [options] &lt;URL&gt;<br>wget -O --show-progress myfile.zip http://www.example.com/testfile.zip  <span class="hljs-comment"># 如果不指定&quot;-O&quot; 选项，wget默认会以 url 路径最后一个 &quot;/&quot; 的后面全部字符为下载的文件名</span><br><br><span class="hljs-comment"># 断点续传</span><br>wget -c http://www.example.com/testfile.zip  <span class="hljs-comment"># 当下载的文件特别大或者网络原因，文件没有下载完连接就已经被断开，使用 -c 选项可以在网络连接恢复时接着上次的下载任务继续下载，而不需要重头开始下载文件</span><br>wget --tries=40 http://www.example.com/testfile.zip  <span class="hljs-comment"># wget默认重试20次连接下载文件，如果网络一直有问题下载可能失败。如果需要的话，你可以使用--tries增加重试次数。</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>下载超时，尝试添加参数<code>--no-cookie --no-check-certificate</code>。</p>
</blockquote>
<h4 id="curl">curl</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单个文件下载</span><br>curl [ -o 自定义文件名| -O] --progress-bar http://www.example.com/index.html<br><span class="hljs-comment"># -o 自定义文件名：把服务器响应输出到指定文件</span><br><span class="hljs-comment"># -O：与-o选项作用一样，区别在于以 url 路径最后一个&quot;/&quot;之后的部分作为文件名</span><br><span class="hljs-comment"># 如果这两个选项都不写，curl 默认会把服务器响应内容输出到终端</span><br><br><span class="hljs-comment"># 断点续传</span><br>curl -O -C 偏移量 http://www.example.com/testfile.zip<br><span class="hljs-comment"># -C 偏移量：从指定的偏移量处继续下载，偏移量以字节为单位</span><br><span class="hljs-comment"># 如果让curl自动推断出正确的续传位置可以使用 &quot;-&quot; 代替偏移量，例如：</span><br>curl -O -C - http://www.example.com/testfile.zip<br></code></pre></td></tr></table></figure>
<h3 id="目录（跳转）">目录（跳转）</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> 新建目录<br><br>./（点斜杠）表示当前工作目录的相对路径<br>.表示当前目录<br>..表示（当前目录的）父目录<br><br><span class="hljs-built_in">pwd</span>  <span class="hljs-comment"># 打印当前所在目录</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-built_in">dir</span>  <span class="hljs-comment"># 切换到指定目录</span><br><span class="hljs-built_in">cd</span> /  <span class="hljs-comment"># 进入根目录</span><br><span class="hljs-built_in">cd</span> ~  <span class="hljs-comment"># root用户， 相当于 cd /root；普通用户，相当于cd /home/当前用户名，即主目录</span><br><span class="hljs-built_in">cd</span>  <span class="hljs-comment"># 相当于 cd ~</span><br><span class="hljs-built_in">cd</span> -  <span class="hljs-comment"># 切换最开始的目录</span><br><span class="hljs-built_in">cd</span> .  <span class="hljs-comment"># 目前所在目录</span><br><span class="hljs-built_in">cd</span> ..  <span class="hljs-comment"># 返回上一层</span><br><span class="hljs-built_in">cd</span> ../..  <span class="hljs-comment"># 返回上两层</span><br><span class="hljs-built_in">cd</span> ../***  <span class="hljs-comment"># 进入当前目录父目录的**目录</span><br><span class="hljs-built_in">cd</span> ~=<span class="hljs-built_in">cd</span> /root  <span class="hljs-comment"># 进入root的根目录</span><br><br><span class="hljs-comment"># 标记目录</span><br><span class="hljs-comment"># 记录当前目录路径，待会返回需要用到</span><br>cur=`<span class="hljs-built_in">pwd</span>`<br><span class="hljs-comment"># 返回项目</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$cur</span><br></code></pre></td></tr></table></figure>
<ol>
<li>
<p>把目录结构信息保存到文本中，树状图：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tree &gt; /home/luke/tree.txt<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>在终端打开文件管理器：<code>nautilus</code>或<code>xdg-open</code>[空格]目标路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">nautilus /path/to/directory  <span class="hljs-comment"># or</span><br>xdg-open /path/to/directory<br><span class="hljs-comment"># 打开当前终端所在目录</span><br>nautilus .  <span class="hljs-comment"># or</span><br>xdg-open .<br></code></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h3 id="压缩解压缩">压缩解压缩</h3>
<h4 id="zip">zip</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 一般处理</span><br>zip -r FileName.zip DirName  <span class="hljs-comment"># 压缩</span><br>unzip test.zip  <span class="hljs-comment"># 解压</span><br>unzip -O GBK 6.zip  <span class="hljs-comment"># 解决解压出来中文乱码</span><br><br><span class="hljs-comment"># 高级处理</span><br><span class="hljs-comment"># 压缩、设置密码且分卷</span><br>zip -r -P 123456 temp.zip data/<br>zip -s 10m temp.zip --out data.zip<br><span class="hljs-comment"># 解压缩分卷</span><br><span class="hljs-comment"># 好用</span><br>sudo apt-get install p7zip<br>sudo apt-get install p7zip-full<br>sudo apt-get install p7zip-rar<br>7z x data.zip  <span class="hljs-comment"># 分卷文件在同一文件夹下，解压首文件即可，不需要合并分卷。密码会在解压终端提示输入。</span><br><span class="hljs-comment"># 不好用</span><br><span class="hljs-built_in">cat</span> data.* &gt; tounzip.zip<br>unzip -P 123456 tounzip.zip<br></code></pre></td></tr></table></figure>
<h4 id="tar">tar</h4>
<blockquote>
<p>.tar.gz = .tgz</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zcvf FileName.tar.gz DirName  <span class="hljs-comment"># 压缩</span><br>tar -zxvf cmake-3.23.0-rc1.tar.gz  <span class="hljs-comment"># 解压</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>-z</code>: 使用 gzip 压缩归档文件</li>
<li><code>-c</code>: 创建新的归档文件</li>
<li><code>-x</code>：解开压缩文件</li>
<li><code>-v</code>: 显示详细输出，列出被添加到归档中的文件</li>
<li><code>-f</code>: 指定归档文件的名称</li>
</ul>
<h4 id="tar-xz">tar.xz</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩</span><br>tar -cvf Image.tar Image/<br>xz -z Image.tar  <span class="hljs-comment"># 如果要保留被压缩的文件加上参数 -k ，如果要设置压缩率加入参数 -0 到 -9 调节压缩率。如果不设置，默认压缩等级是6。</span><br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-comment"># 先将Image.tar.xz 解压成 Image.tar</span><br>xz -d Image.tar.xz  <span class="hljs-comment"># 使用 -k 参数来保留被解压缩的文件。</span><br>tar -xvf Image.tar  <span class="hljs-comment"># 再用tar xvf Image.tar来解包</span><br></code></pre></td></tr></table></figure>
<p>xz的参数：</p>
<ul>
<li><code>-z, --compress</code>: 强制压缩</li>
<li><code>-d, --decompress</code>: 强制解压</li>
<li><code>-k, --keep</code>: 保留（不删除）输入文件</li>
</ul>
<h4 id="pigz">pigz</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩文件（夹）</span><br>tar --use-compress-program=pigz -cvpf  /目录名/文件名.tgz （空格） /boot（压缩的文件或者目录）<br>--use-compress-program=pigz  是指定 （ pigz ）来进行压缩<br>-cvpf   <br>-c    创建压缩文件    <br>-v    显示压缩或解压的过程    <br>-p    保留原始的权限与属性  <br>-f    目标文件名   <br>--exclude=/xx  排除这个目录不压缩<br><br><span class="hljs-comment"># 解压文件（夹）</span><br>tar --use-compress-program=pigz -xvpf 文件.tgz -C  / （这是指定解压到了根目录）（不加默认解压到当前文件夹）<br>--use-compress-program=pigz  是指定 （ pigz ）来进行解压<br>-xvpf  <br>-x    解开压缩文件    <br>-v    显示压缩或解压的过程    <br>-p    保留原始的权限与属性  <br>-f    目标文件名   <br>-C    指定解压到的目录<br></code></pre></td></tr></table></figure>
<h3 id="设置文件权限">设置文件权限</h3>
<h4 id="chmod">chmod</h4>
<p>指令名称：<code>chmod</code></p>
<p>使用权限：所有使用者</p>
<p>使用方式：<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<p>参数格式：</p>
<ul>
<li><code>u</code>：表示该档案的拥有者。</li>
<li><code>g</code>：表示与该档案的拥有者属于同一个群体(group)者。</li>
<li><code>o</code>：表示其他以外的人。</li>
<li><code>a</code>：表示这三者皆是。</li>
<li><code>+</code>：表示增加权限。</li>
<li><code>-</code>：表示取消权限。</li>
<li><code>=</code>：表示唯一设定权限。</li>
<li><code>r</code>：表示可读取。</li>
<li><code>w</code>：表示可写入。</li>
<li><code>x</code>：表示可执行。</li>
<li><code>X</code>：表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</li>
<li><code>R</code>：对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将档案 file1.txt 设为所有人皆可读取</span><br><span class="hljs-built_in">chmod</span> ugo+r file1.txt  <span class="hljs-comment"># 或</span><br><span class="hljs-built_in">chmod</span> a+r file1.txt<br><span class="hljs-comment"># 将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入</span><br><span class="hljs-built_in">chmod</span> ug+w,o-w file1.txt file2.txt<br><span class="hljs-comment"># 将目前目录下的所有档案与子目录皆设为任何人可读取</span><br><span class="hljs-built_in">chmod</span> -R a+r *<br></code></pre></td></tr></table></figure>
<p>此外<code>chmod</code>也可以用数字来表示权限，语法为：<code>chmod abc file</code>，其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<p>一般是三个数字：</p>
<ul>
<li>第一个数字表示文件所有者的权限。</li>
<li>第二个数字表示与文件所有者同属一个用户组的其他用户的权限。</li>
<li>第三个数字表示其它用户组的权限。</li>
</ul>
<p>权限分为三种：读（r=4），写（w=2），执行（x=1）。综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。</p>
<p>所以，<code>chmod 755</code> 设置用户的权限为：</p>
<ol>
<li>文件所有者可读可写可执行</li>
<li>与文件所有者同属一个用户组的其他用户可读可执行</li>
<li>其它用户组可读可执行</li>
</ol>
<p>777就是rwxrwxrwx，意思是该登录用户（可以用命令id查看）、他所在的组和其他人都有最高权限。</p>
<p><code>chmod 4755</code>与<code>chmod 755</code> 的区别在于开头多了一位，这个4表示其他用户执行文件时，具有与所有者相当的权限。具有root的权限。</p>
<p><code>chmod a=rwx file</code> 和<code>chmod 777 file</code>效果相同。</p>
<p><code>chmod ug=rwx,o=x file</code>和<code>chmod 771 file</code>效果相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看文件权限</span><br>ll<br></code></pre></td></tr></table></figure>
<h4 id="chown">chown</h4>
<h5 id="用法-2">用法</h5>
<blockquote>
<p>在 Linux/Unix 系统下，<code>chown</code> 命令用于更改文件或目录的拥有者（user）和所属组（group）。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [-cfhvR] [--<span class="hljs-built_in">help</span>] [--version] user[:group] file...<br></code></pre></td></tr></table></figure>
<ul>
<li>user : 新的文件拥有者的使用者 ID</li>
<li>group : 新的文件拥有者的使用者组(group)</li>
<li>-c : 显示更改的部分的信息</li>
<li>-f : 忽略错误信息</li>
<li>-h :修复符号链接</li>
<li>-v : 显示详细的处理信息</li>
<li>-R : 处理指定目录以及其子目录下的所有文件</li>
<li>--help : 显示辅助说明</li>
<li>--version : 显示版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chown</span> -R $(<span class="hljs-built_in">whoami</span>):$(<span class="hljs-built_in">whoami</span>) filepath<br></code></pre></td></tr></table></figure>
<h5 id="user和group的区别">user和group的区别</h5>
<ul>
<li><strong>user</strong> 指的是文件/目录的“所有者”（Owner），即一个具体的用户账号，比如 <code>alice</code>、<code>bob</code>、<code>root</code> 等。
<ul>
<li>拥有者对文件有<strong>独立权限</strong>（如读、写、执行）。</li>
</ul>
</li>
<li><strong>group</strong> 指的是文件/目录归属的“用户组”（Group），比如 <code>staff</code>、<code>wheel</code>、<code>users</code>、<code>developers</code> 等。
<ul>
<li>一个用户可以属于多个组，文件的 group 权限控制“同组成员”能否访问、修改文件。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> bob file.txt <span class="hljs-comment"># 只改拥有者：拥有者变为 bob，组不变</span><br><span class="hljs-built_in">chown</span> :wheel file.txt <span class="hljs-comment"># 只改组：组变为 wheel，拥有者不变</span><br><span class="hljs-built_in">chown</span> bob:wheel file.txt  <span class="hljs-comment"># 同时改：拥有者变为 bob，组变为 wheel</span><br></code></pre></td></tr></table></figure>
<h4 id="chown和chmod的区别">chown和chmod的区别</h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>主要作用</th>
<th>控制内容</th>
<th>典型命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>chown</td>
<td>更改拥有者和用户组</td>
<td>user/group</td>
<td><code>chown bob:staff file.txt</code></td>
</tr>
<tr>
<td>chmod</td>
<td>更改文件访问权限</td>
<td>r/w/x权限</td>
<td><code>chmod 755 file.txt</code></td>
</tr>
</tbody>
</table>
<ul>
<li><code>chown</code> = 谁“拥有”这个文件/文件夹
<ul>
<li><strong><code>chown</code> 只是更改文件的拥有者（user）和用户组（group）</strong>，并不会自动更改文件的读、写、执行权限设置。</li>
<li>文件原有的权限（rwx）<strong>不会改变</strong>，只是“谁”享有这些权限的身份发生了变化。</li>
</ul>
</li>
<li><code>chmod</code> = “拥有者/组/其他人”各自拥有哪些读/写/执行权限</li>
</ul>
<h4 id="root用户把某个文件权限给到普通用户">root用户把某个文件权限给到普通用户</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先切换到root环境</span><br>su root<br><span class="hljs-comment"># 赋权</span><br><span class="hljs-built_in">chown</span> -R username filepath<br><span class="hljs-comment"># username 指的是 你的普通用户名称</span><br><span class="hljs-comment"># filepath 指的是 你需要赋权给普通用户的文件夹路径</span><br><span class="hljs-comment"># 这样普通用户也就可以操作这个路径下的文件了</span><br><br><span class="hljs-comment"># 示例：</span><br>sudo <span class="hljs-built_in">chown</span> -R $(<span class="hljs-built_in">whoami</span>):$(<span class="hljs-built_in">whoami</span>) filepath<br></code></pre></td></tr></table></figure>
<h3 id="软-硬链接">软/硬链接</h3>
<h4 id="区别">区别</h4>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-ln.html">Linux ln 命令 - 菜鸟教程</a></p>
<ol>
<li><strong>硬链接</strong>：
<ul>
<li>对源文件创建硬链接，修改源文件，被硬链接的文件也会被修改；修改被硬链接的文件，源文件也会被修改。</li>
<li>删除源文件，被硬链接的文件不受影响，因为硬链接和源文件指向相同的文件数据，只有当所有指向该数据的链接都被删除时，文件数据才会被删除。</li>
<li>不允许给目录创建硬链接。</li>
<li>硬链接只有在同一个文件系统中才能创建。（例如，电脑文件硬链接不到 U 盘）</li>
</ul>
</li>
<li><strong>软链接</strong>：
<ul>
<li>对源文件创建软链接，类似于对源文件创建快捷方式。</li>
<li>删除源文件，软链接会失效，因为软链接只是指向源文件路径的引用。</li>
<li>软链接可以对目录进行链接。</li>
<li>软链接可以跨文件系统 ，硬链接不可以。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li><strong>硬链接</strong>：多个文件名指向同一个文件数据，删除其中一个文件名不会影响文件数据的存在。</li>
<li><strong>软链接</strong>：一个文件名指向另一个文件名，删除源文件会导致软链接失效。</li>
</ul>
<h4 id="创建">创建</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> [参数][源文件或目录][目标文件或目录]<br></code></pre></td></tr></table></figure>
<ul>
<li><code>-s</code>: 软链接(符号链接)</li>
<li><code>-v</code>: 显示详细的处理过程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给文件创建软链接，为log2013.log文件创建软链接link2013.log，如果log2013.log丢失，link2013.log将失效：</span><br><span class="hljs-built_in">ln</span> -s log2013.log link2013.log<br><span class="hljs-comment"># 给文件创建硬链接，为log2013.log创建硬链接ln2013.log，log2013.log与ln2013.log的各项属性相同</span><br><span class="hljs-built_in">ln</span> log2013.log ln2013.log<br></code></pre></td></tr></table></figure>
<blockquote>
<p>如果为源文件创建的目标（硬）链接是文件夹，则会在该文件夹下创建于源文件同名的文件。</p>
</blockquote>
<p>你可以使用 <code>find</code> 命令结合 <code>ln</code> 命令来为指定目录下的所有文件在另一个目录下创建硬链接。以下是一个示例脚本，假设你要为 <code>source_dir</code> 目录下的所有文件在 <code>target_dir</code> 目录下创建硬链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>source_dir=<span class="hljs-string">&quot;/path/to/source_dir&quot;</span><br>target_dir=<span class="hljs-string">&quot;/path/to/target_dir&quot;</span><br><br><span class="hljs-comment"># 创建目标目录（如果不存在）</span><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_dir&#125;</span>&quot;</span><br><br><span class="hljs-comment"># 遍历 source_dir 目录下的所有文件，并在 target_dir 目录下创建硬链接</span><br>find <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;source_dir&#125;</span>&quot;</span> -<span class="hljs-built_in">type</span> f | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> -r file; <span class="hljs-keyword">do</span><br>    <span class="hljs-comment"># 获取相对路径</span><br>    relative_path=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;file#<span class="hljs-variable">$&#123;source_dir&#125;</span>/&#125;</span>&quot;</span><br>    <span class="hljs-comment"># 创建硬链接的目标路径</span><br>    target_file=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_dir&#125;</span>/<span class="hljs-variable">$&#123;relative_path&#125;</span>&quot;</span><br>    <span class="hljs-comment"># 创建目标文件所在的目录（如果不存在）</span><br>    <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_file&#125;</span>&quot;</span>)</span>&quot;</span><br>    <span class="hljs-comment"># 创建硬链接</span><br>    <span class="hljs-built_in">ln</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;file&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;target_file&#125;</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<p>以下是如何在Python中创建硬链接和软链接的示例代码：</p>
<p>创建硬链接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_hard_link</span>(<span class="hljs-params">src_file, dest_file</span>):<br>    <span class="hljs-keyword">try</span>:<br>        os.link(src_file, dest_file)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;硬链接已创建：<span class="hljs-subst">&#123;src_file&#125;</span> -&gt; <span class="hljs-subst">&#123;dest_file&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">except</span> FileExistsError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标文件已存在：<span class="hljs-subst">&#123;dest_file&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;创建硬链接失败：<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br>src_file = <span class="hljs-string">&quot;path/to/your/file.txt&quot;</span><br>dest_file = <span class="hljs-string">&quot;path/to/backup/folder/file.txt&quot;</span><br>create_hard_link(src_file, dest_file)<br></code></pre></td></tr></table></figure>
<p>创建软链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">import os<br><br>def create_soft_link(src_file, dest_file):<br>    try:<br>        os.symlink(src_file, dest_file)<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;软链接已创建：&#123;src_file&#125; -&gt; &#123;dest_file&#125;&quot;</span>)<br>    except FileExistsError:<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;目标文件已存在：&#123;dest_file&#125;&quot;</span>)<br>    except OSError as e:<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;创建软链接失败：&#123;e&#125;&quot;</span>)<br><br>src_file = <span class="hljs-string">&quot;path/to/your/file.txt&quot;</span><br>dest_file = <span class="hljs-string">&quot;path/to/backup/folder/file.txt&quot;</span><br>create_soft_link(src_file, dest_file)<br></code></pre></td></tr></table></figure>
<h4 id="查看">查看</h4>
<ul>
<li>
<p>软链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ll<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>硬链接。在Linux终端中，可以使用ls命令配合-i选项来查看文件的inode号，从而识别硬链接。所有具有相同inode号的文件都是同一个文件的硬链接。以下是具体步骤：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用ls -i命令查看文件的inode号：</span><br><span class="hljs-built_in">ls</span> -i file1<br><span class="hljs-comment"># 使用find命令查找具有相同inode号的所有文件：</span><br>find . -inum &lt;inode_number&gt;  <span class="hljs-comment"># . 表示载当前目录及其子目录下进行查找，可以换成其它指定目录。</span><br><span class="hljs-comment"># 这样，你就可以看到所有指向同一个inode的硬链接文件。</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="硬盘">硬盘</h3>
<h4 id="挂载硬盘">挂载硬盘</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载 U 盘根目录的内容会直接出现在 /mnt/ 文件夹内，</span><br><span class="hljs-comment"># 而不是 /mnt/ 文件夹内先有一个U盘的名称，名称文件夹内再有内容。</span><br><span class="hljs-comment"># 因此，如有需要，需要提前在 /mnt/ 下使用 sudo  新建文件夹。</span><br>sudo mount /dev/sdX1 /mnt/  <span class="hljs-comment"># mount part</span><br>sudo umount /mnt/  <span class="hljs-comment"># 卸载</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>其中，<code>/dev/sdX1</code>是U盘的设备名，你可以使用<code>lsblk</code>或<code>fdisk -l</code>命令来查找U盘的设备名。</p>
<p>例如，插入硬盘前后，使用<code>lsblk</code>发现新增：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sdc      8:32   0   7.3T  0 disk <br>└─sdc1   8:33   0   7.3T  0 part<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="硬盘类型">硬盘类型</h4>
<p>在Linux系统上，可以使用以下命令来查看硬盘是机械硬盘（HDD）还是固态硬盘（SSD）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /sys/block/sdX/queue/rotational<br></code></pre></td></tr></table></figure>
<p>将<code>sdX</code>替换为硬盘的设备名，比如<code>sda</code>。如果输出是<code>1</code>，则表示是机械硬盘；如果输出是<code>0</code>，则表示是固态硬盘。</p>
<p>除了查看<code>/sys/block</code>目录下的信息外，你还可以使用<code>lsblk</code>命令结合<code>-o</code>选项来获取更多详细信息，包括硬盘类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk -d -o name,rota<br></code></pre></td></tr></table></figure>
<ul>
<li><code>lsblk</code> 列出所有块设备。</li>
<li><code>-d</code> 选项只显示磁盘本身，不显示其分区。</li>
<li><code>-o</code> 选项指定要显示的列，其中<code>name</code>表示设备名，<code>rota</code>表示是否是旋转设备（0表示固态硬盘，1表示机械硬盘）。</li>
</ul>
<p>通过这种方式，你可以在一个命令中看到所有硬盘的类型。</p>
<h3 id="模拟鼠标键盘">模拟鼠标键盘</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/jordansissel/xdotool">https://github.com/jordansissel/xdotool</a></p>
<p>作用：<code>xdotool</code>允许您以编程方式（或手动）模拟键盘输入和鼠标活动、移动窗口和调整窗口大小等。</p>
<p>用户文档：<a target="_blank" rel="noopener" href="https://github.com/jordansissel/xdotool/blob/master/xdotool.pod">https://github.com/jordansissel/xdotool/blob/master/xdotool.pod</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carefree2005/article/details/125809615">Linux之xdotool工具安装及实践</a></p>
<h4 id="安装-2">安装</h4>
<ul>
<li>Debian and Ubuntu: <code>apt-get install xdotool</code></li>
<li>Fedora: <code>dnf install xdotool</code></li>
<li>FreeBSD: <code>pkg install xdotool</code></li>
<li>macOS: <code>brew install xdotool</code> or <code>sudo port install xdotool</code></li>
<li>OpenSUSE: <code>zypper install xdotool</code></li>
</ul>
<h4 id="使用">使用</h4>
<blockquote>
<p>xdotool 支持在一次调用中运行多个命令。</p>
</blockquote>
<blockquote>
<p>在 GNOME 终端中使用<code>xdotool key Ctrl+c</code>是成功的，使用<code>xdotool key Ctrl+C</code>是失败的（<code>xdotool key ctrl+c</code>在 ROS 下失败），关键在于字母<code>c</code>要小写。在 Terminator 窗口下没有此现象。因此，干脆没有特殊要求就直接用小写吧。</p>
</blockquote>
<h5 id="帮助">帮助</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">xdotool <span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure>
<h5 id="键盘">键盘</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发送按键</span><br>xdotool key [options] keystroke [keystroke ...]<br>[options]<br>--window window <span class="hljs-comment"># 将击键发送到特定窗口 ID</span><br>--clearmodifiers  <span class="hljs-comment"># 在发送击键之前清除修饰符</span><br>--delay milliseconds   <span class="hljs-comment"># 按键之间的延迟。默认值为 12 毫秒</span><br><br><span class="hljs-comment"># 示例</span><br>xdotool key Ctrl+Shift+W BackSpace<br></code></pre></td></tr></table></figure>
<blockquote>
<p>模拟打字并按回车键：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">xdotool <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;s</span><br><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发送按下/释放按键的事件</span><br>xdotool keydown/keyup [options] keystroke<br> * keydown  <span class="hljs-comment"># [options] 与 key 相同，只是仅发送 keydown（按下）事件。</span><br> * keyup  <span class="hljs-comment"># [options] 与 key 相同，只是仅发送 keyup（释放）事件。</span><br><span class="hljs-comment"># 示例</span><br>xdotool keydown n<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发送字符串</span><br>xdotool <span class="hljs-built_in">type</span> [options] something to <span class="hljs-built_in">type</span> <span class="hljs-comment"># [options] 与 key 相同</span><br><span class="hljs-comment"># 示例</span><br>xdotool <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;Hello world!&#x27;</span><br></code></pre></td></tr></table></figure>
<h5 id="鼠标-2">鼠标</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将鼠标移动到屏幕上的特定 X 和 Y 坐标。</span><br>xdotool mousemove [options] x y OR <span class="hljs-string">&#x27;restore&#x27;</span><br><br><span class="hljs-comment"># 如果指定“restore”而不是 X 和 Y 坐标，则可以将鼠标移动到之前的位置。仅当您之前在同一命令调用中进行过移动时，restore 才有效。此外，它不适用于 --window 选项。</span><br><span class="hljs-comment"># 示例</span><br>xdotool mousemove 0 0 click 1 mousemove restore  <span class="hljs-comment"># 单击屏幕左上角并将鼠标移动到移动之前的原始位置</span><br><br>[options]<br>--window WINDOW  <span class="hljs-comment"># 指定要相对移动的窗口。坐标 0,0 位于您选择的窗口的左上角。</span><br>--screen SCREEN   <span class="hljs-comment"># 将鼠标移动到要移动到的指定屏幕。仅当您有多个屏幕并且不使用 Xinerama 时，这才有用。默认为当前屏幕。如果指定 --window，则忽略 --screen 标志。</span><br>--polar  <span class="hljs-comment"># 使用极坐标。这使得“x”成为角度（以度为单位，0-360 等），“y”成为距离。旋转从“向上”（0 度）开始并顺时针旋转：90 = 向右，180 = 向下，270 = 向左。原点默认为当前屏幕的中心。如果指定 --window，则原点是该窗口的中心。</span><br>--clearmodifiers  <span class="hljs-comment"># 清除修饰符</span><br>--<span class="hljs-built_in">sync</span>  <span class="hljs-comment"># 发送鼠标移动请求后，等待鼠标实际移动。如果没有必要采取行动，我们就不会等待。这对于依赖于在继续之前完成的操作的脚本非常有用。</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 相对于鼠标光标的当前位置移动鼠标 x,y 像素。</span><br>xdotool mousemove_relative [options] x y  <span class="hljs-comment"># [options] 与 mousemove 相同</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 模拟单击</span><br>xdotool click [options] button<br><span class="hljs-comment"># 按钮通常这样映射：鼠标左键为 1，中键为 2，右键为 3，向上滚轮为 4，向下滚轮为 5。</span><br><br>[options]<br>--clearmodifiers  <span class="hljs-comment"># 单击之前清除修饰符</span><br>--repeat REPEAT  <span class="hljs-comment"># 指定单击次数。默认值为 1。对于双击，请使用“--repeat 2”</span><br>--delay MILLISECONDS  <span class="hljs-comment"># 指定单击之间的延迟时间（以毫秒为单位）。如果--repeat标志设置为 1（默认），则不使用此选项。</span><br>--window WINDOW  <span class="hljs-comment"># 指定要向其发送点击的窗口。</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 与 click 相同，但仅发送鼠标按下/松开操作。</span><br>xdotool mousedown/mouseup [options] button<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出鼠标光标的 x、y、屏幕和窗口 ID。如果您有多个显示器并且不使用 Xinerama，则屏幕编号将非零。</span><br>xdotool getmouselocation [--shell]<br>--shell  <span class="hljs-comment"># 这使得 getmouselocation 输出可以 eval 的 shell 数据。</span><br><br><span class="hljs-comment"># 示例</span><br>% xdotool getmouselocation --shell<br>X=880<br>Y=443<br>SCREEN=0<br>WINDOW=16777250<br><br>% <span class="hljs-built_in">eval</span> $(xdotool getmouselocation --shell)<br>% <span class="hljs-built_in">echo</span> <span class="hljs-variable">$X</span>,<span class="hljs-variable">$Y</span><br>714,324<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当鼠标点击屏幕边缘或角落时，将操作绑定到事件。</span><br>xdotool behave_screen_edge [options] <span class="hljs-built_in">where</span> <span class="hljs-built_in">command</span> ...<br><span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure>
<h5 id="窗口-2">窗口</h5>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 搜索具有正则表达式模式的标题、名称或类的窗口。</span><br>xdotool search [options] pattern<br><span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过单击获取窗口 ID（针对客户端）。对于让脚本向您询问要在哪个窗口上执行操作非常有用。</span><br><span class="hljs-comment"># 例如，通过单击来杀死一个窗口：</span><br>xdotool selectwindow windowkill<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将操作绑定到窗口上的事件。这使您可以在发生匹配事件时运行其他 xdotool 命令。</span><br>xdotool behave window action <span class="hljs-built_in">command</span> ...<br> * mouse-enter  <span class="hljs-comment"># 当鼠标进入窗口时触发。</span><br> * mouse-leave  <span class="hljs-comment"># 当鼠标离开窗口时触发。</span><br> * mouse-click  <span class="hljs-comment"># 单击鼠标时触发。具体来说，当释放鼠标按钮时。</span><br> * focus  <span class="hljs-comment"># 当窗口获得输入焦点时触发。</span><br> * blur  <span class="hljs-comment"># 当窗口失去焦点时触发。</span><br> <br> <span class="hljs-comment"># 示例</span><br> <span class="hljs-comment"># Print the cursor location whenever the mouse enters a currently-visible</span><br><span class="hljs-comment"># window:</span><br>xdotool search --onlyvisible . behave %@ mouse-enter getmouselocation<br><br><span class="hljs-comment"># Print the window title and pid whenever an xterm gets focus</span><br>xdotool search --class xterm behave %@ focus getwindowname getwindowpid<br><br><span class="hljs-comment"># Emulate focus-follows-mouse</span><br>xdotool search . behave %@ mouse-enter windowfocus<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前活动窗口。该命令通常比 getwindowfocus 更可靠。结果保存到窗口堆栈中。</span><br>xdotool getactivewindow<br><br><span class="hljs-comment"># 打印当前焦点窗口的窗口 ID。将结果保存到窗口堆栈。</span><br>xdotool getwindowfocus [-f]<br><span class="hljs-comment"># 如果当前窗口没有 WM_CLASS 属性，我们假设它不是一个普通的顶级窗口，并向上遍历父窗口，直到找到一个设置了 WM_CLASS 的窗口并返回该窗口 id。</span><br><span class="hljs-comment"># 如果您确实希望当前窗口具有焦点并且不关心它是否具有 WM_CLASS 设置，请使用“getwindowfocus -f”</span><br><br><span class="hljs-comment"># 激活窗口。</span><br><span class="hljs-comment"># 该命令与 windowfocus 不同：如果窗口位于另一个桌面上，我们将切换到该桌面。它还使用不同的方法来打开窗口。</span><br>xdotool windowactivate [options] [window]<br><br><span class="hljs-comment"># 输出拥有给定窗口的 PID。</span><br>xdotool getwindowpid [window]<br><span class="hljs-comment"># 如果未给出窗口，则默认值为“%1”。如果堆栈上没有窗口，则这是一个错误。</span><br><br><span class="hljs-comment"># 输出给定窗口的名称，也称为标题。这是窗口管理器在窗口标题栏中显示的文本。</span><br>xdotool getwindowname [window]<br><span class="hljs-comment"># 如果未给出窗口，则默认值为“%1”。如果堆栈上没有窗口，则这是一个错误。</span><br><br><span class="hljs-comment"># 输出窗口的几何形状（位置和位置）。这些值包括：x、y、宽度、高度和屏幕编号。</span><br>xdotool getwindowgeometry [options] [window]<br>--shell  <span class="hljs-comment"># 适合 shell 中“eval”的输出值。</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭一个窗口。此操作将破坏窗口，但不会尝试杀死控制它的客户端。</span><br>xdotool windowclose [window]<br><br><span class="hljs-comment"># 优雅地关上窗户。此操作发送请求，允许应用程序应用关闭确认机制。</span><br>xdotool windowquit [window]<br><br><span class="hljs-comment"># 杀死一扇窗户。此操作将破坏窗口并杀死控制它的客户端。</span><br>xdotool windowkill [window]<br><br><span class="hljs-comment"># 设置有关窗口的属性。</span><br>xdotool set_window [options] [windowid=%1]<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 更改窗口的属性。</span><br>windowstate [--add PROPERTY] [--remove PROPERTY] [--toggle PROPERTY] [window]<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 设置给定窗口的窗口大小</span><br>xdotool windowsize [options] [window] width height<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 将窗口移动到给定位置</span><br>xdotool windowmove [options] [window] x y<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 聚焦一个窗口</span><br>xdotool windowfocus [options] [window]<br>--<span class="hljs-built_in">sync</span>  <span class="hljs-comment"># 发送窗口焦点请求后，等待窗口真正获得焦点。这对于依赖于在继续之前完成的操作的脚本非常有用。</span><br><br><span class="hljs-comment"># 映射一个窗口。在 X11 术语中，映射窗口意味着使其在屏幕上可见。</span><br>xdotool windowmap [options] [window]<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 取消映射窗口，使其不再出现在屏幕上。</span><br>xdotool windowunmap [options] [window_id=%1]<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 最小化一个窗口。</span><br>xdotool windowminimize [options] [window]<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 将窗口提升到堆栈顶部。</span><br>xdotool windowraise [window_id=%1]<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 将窗口降低到堆栈底部。</span><br>xdotool windowlower [window_id=%1]<br><span class="hljs-comment"># 略</span><br><br><span class="hljs-comment"># 重新设置窗口的父级。</span><br>xdotool windowreparent [source_window] destination_window<br><span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure>
<h3 id="sleep">sleep</h3>
<p>Linux sleep命令可以用来将目前动作延迟一段时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sleep</span> [--<span class="hljs-built_in">help</span>] [--version] number[smhd]<br></code></pre></td></tr></table></figure>
<ul>
<li><code>--help</code> : 显示辅助讯息</li>
<li><code>--version</code> : 显示版本编号</li>
<li><code>number</code> : 时间长度，后面可接 s、m、h 或 d。其中 s 为秒，m 为 分钟，h 为小时，d 为日数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sleep</span> 5m  <span class="hljs-comment"># 休眠5分钟</span><br></code></pre></td></tr></table></figure>
<h3 id="后台运行">后台运行</h3>
<p>有时，您需要执行一个即使在您注销终端会话后也会继续运行的命令。<code>nohup</code>（无挂起）命令允许您在后台运行进程而不会中断。例如，使用<code>nohup long_running_command &amp;</code>在后台启动命令，即使在关闭终端后也能保持其运行。此功能对于执行需要在没有持续监督的情况下持续存在的冗长任务或脚本特别有价值。</p>
<h3 id="并行运行">并行运行</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">command1 &amp; command2 &amp; command3<br>parallel ::: command1 command2 command3<br></code></pre></td></tr></table></figure>
<h3 id="定时关机">定时关机</h3>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-shutdown.html">https://www.runoob.com/linux/linux-comm-shutdown.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdown [-t seconds] [-rkhncfF] time [message]<br></code></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<ul>
<li>-t seconds : 设定在几秒钟之后进行关机程序。</li>
<li>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。</li>
<li>-r : 关机后重新开机。</li>
<li>-h : 关机后停机。</li>
<li>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。</li>
<li>-c : 取消目前已经进行中的关机动作。</li>
<li>-f : 关机时，不做 fsck 动作(检查 Linux 档系统)。</li>
<li>-F : 关机时，强迫进行 fsck 动作。</li>
<li>time : 设定关机的时间。</li>
<li>message : 传送给所有使用者的警告讯息。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo shutdown -h now  <span class="hljs-comment"># 立即关机</span><br>sudo shutdown -h 10  <span class="hljs-comment"># 指定 10 分钟后关机</span><br>sudo shutdown -r now  <span class="hljs-comment"># 重新启动计算机</span><br>sudo shutdown -c  <span class="hljs-comment"># 取消定时关机</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install at<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;sudo shutdown -h now&quot;</span> | at 23:00  <span class="hljs-comment"># 在晚上 11 点关机</span><br></code></pre></td></tr></table></figure>
<h3 id="Shebang">Shebang</h3>
<p>在Linux或Unix系统中，Shebang（亦称为释伴）是一个由井号(#)和叹号(!)组成的字符序列，通常位于脚本文件的第一行。Shebang指明了执行该脚本文件的解释器路径，使得脚本可以像普通的可执行文件一样被调用。</p>
<p><strong>shebang（如 <code>#!/usr/bin/zsh</code>）</strong> 只有在你直接执行脚本（如 <code>./test.sh</code>）时才决定用哪个解释器。当你用<code>bash test.sh</code>运行时，系统会：</p>
<ol>
<li>启动你命令里写明的 <code>bash</code>。</li>
<li><code>bash</code> 再去读取 <code>test.sh</code> 的内容并执行，<strong>不会理会 shebang</strong>。</li>
</ol>
<p>所以，无论 <code>test.sh</code> 开头写什么 shebang，<code>bash test.sh</code> 都是用 <code>bash</code> 解释运行。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>./test.py</code></th>
<th><code>python test.py</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>依赖 shebang</strong></td>
<td>是，shebang 必须正确指定解释器</td>
<td>否，解释器由用户显式调用</td>
</tr>
<tr>
<td><strong>文件可执行权限</strong></td>
<td>需要（<code>chmod +x test.py</code>）</td>
<td>不需要</td>
</tr>
<tr>
<td><strong>解释器版本选择的灵活性</strong></td>
<td>固定，由 shebang 指定</td>
<td>用户可以自由选择解释器</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>脚本自动化、作为独立命令运行</td>
<td>开发和调试脚本，或需要指定特定解释器版本</td>
</tr>
</tbody>
</table>
<h3 id="小贴士">小贴士</h3>
<h4 id="Linux顺序执行多行命令">Linux顺序执行多行命令</h4>
<ul>
<li>分号<code>;</code>
<ul>
<li>没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。</li>
</ul>
</li>
<li>逻辑或<code>||</code>
<ul>
<li>当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。</li>
</ul>
</li>
<li>逻辑与<code>&amp;&amp;</code>
<ul>
<li>当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 <code>||</code> 正好相反。</li>
</ul>
</li>
<li>管道符<code>|</code>
<ul>
<li>当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。</li>
</ul>
</li>
</ul>
<h4 id="在Linux中使用AppImage">在Linux中使用AppImage</h4>
<ol>
<li>
<p>使其可执行。右键-属性-权限-允许将文件作为程序执行；或，命令行执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> u+x &lt;AppImage File&gt;<br><span class="hljs-comment"># u	user	文件所有者</span><br><span class="hljs-comment"># +	为指定的用户类型增加权限</span><br><span class="hljs-comment"># x	执行权限	设置为可执行权限</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>运行 AppImage 文件。使 AppImage 文件可执行后，只需双击它即可运行它。它将看到该软件正在运行，就像您在系统上安装它一样；或，命令行执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./app.appimage  <span class="hljs-comment"># sudo</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>卸载 AppImage 软件。由于从未安装过该软件，因此无需“卸载”它。只需删除关联的 AppImage 文件，您的软件就会从系统中删除。</p>
</li>
</ol>
<h4 id="其它">其它</h4>
<ol>
<li>
<p>Linux <a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-diff.html">diff</a> 命令用于比较文件的差异。<code>diff</code> 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 <code>diff</code> 会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
</li>
<li>
<p>指令需要root权限，要么命令前加<code>sudo</code>进行提权，要么以<code>root</code>身份执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 首次进入 root 用户模式</span><br><span class="hljs-comment"># 开启一个新的终端</span><br><br><span class="hljs-comment"># 设置 root 用户密码（Linux下输入的密码默认不会显示出来）</span><br>sudo passwd root <br><span class="hljs-comment"># 输入一个新的密码： yourpassword</span><br><span class="hljs-comment"># 请在确认一遍密码： yourpassword</span><br><br><span class="hljs-comment"># 切换到root用户</span><br>su root<br><span class="hljs-comment"># 输入刚刚设置的密码</span><br><br><span class="hljs-comment"># 退出root用户</span><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>$</code>表示普通用户，<code>#</code>表示root用户。</p>
</li>
<li>
<p>定义环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo gedit ~/.bashrc<br><span class="hljs-built_in">export</span> OPENAI_API_KEY=&#123;Your OpenAI API Key here&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><code>timeout</code>是用来控制程序运行的时间，运行指定的命令。如果在指定时间后仍在运行，则杀死该进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">timeout</span> 5s ping www.baidu.com  <span class="hljs-comment"># 5分钟之后终止ping操作</span><br> s : 秒 (默认)<br> m : 分钟<br> h : 小时<br> d : 天<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>等等。</p>
</li>
</ol>
<h2 id="小贴士-2">小贴士</h2>
<ol>
<li>直接在当前文件夹窗口打字，可以搜索该目录及子目录下的文件（夹）。按<code>ESC</code>键退出。</li>
<li><code>Application</code> 键即位置在键盘上右 <code>Ctrl</code> 键左边的那个键，作用相当于单击鼠标右键。</li>
<li>误按<code>Ctrl+Alt+F7</code>（进入文字界面）黑屏后按<code>Ctrl+Alt+F1</code>回到图形界面。</li>
<li>直接将&quot;文件管理器&quot;中的文件拖到&quot;终端&quot;中就可以在终端中得到完整的路径名。</li>
</ol>
<h1 id="终端Terminal">终端Terminal</h1>
<h2 id="命令行解释器Shell">命令行解释器Shell</h2>
<blockquote>
<p>终端负责是从用户这里接收输入（键盘、鼠标等输入设备），扔给 Shell，然后把 Shell 返回的结果展示给用户（比如通过显示器）。而 Shell 负责从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。</p>
</blockquote>
<h3 id="Bash">Bash</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Tab</td>
<td style="text-align:center">zsh自动补全</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+C</td>
<td style="text-align:center">终止进程/命令</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+V</td>
<td style="text-align:center">插入特殊字符。当你按下Ctrl+V后，终端会等待你输入下一个字符，然后将其ASCII值插入到当前位置。例如，如果你按下Ctrl+V然后按Enter，终端将插入一个表示换行的特殊字符。</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+C</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+V</td>
<td style="text-align:center">粘贴</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+F</td>
<td style="text-align:center">查找</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+T</td>
<td style="text-align:center">新建标签页</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+N</td>
<td style="text-align:center">新建同路径窗口</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+W</td>
<td style="text-align:center">关闭标签页</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+Q</td>
<td style="text-align:center">关闭窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+A</td>
<td style="text-align:center">光标移动到开始位置</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+E</td>
<td style="text-align:center">光标移动到最末尾</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+K</td>
<td style="text-align:center">删除此处至末尾的所有内容</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+U</td>
<td style="text-align:center">删除此处至开始的所有内容</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+W</td>
<td style="text-align:center">当在控制台或一个xterm窗口敲入文本时, CTRL+W 会删除从在光标处往后（回）的第一个空白符之间的内容。在某些设置里, CTRL+W 删除光标往后（回）到第一个非文字和数字之间的字符。</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+L</td>
<td style="text-align:center">类似于<code>clear</code>，即清屏。其实只是把光标位置移动到屏幕顶部，仍保留了之前的终端内容。</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Y</td>
<td style="text-align:center">将之前已经清除的文本粘贴回来（主要针对CTRL+U或CTRL+W）。</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+S</td>
<td style="text-align:center">冻结终端</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Q</td>
<td style="text-align:center">解冻终端</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+T</td>
<td style="text-align:center">将光标位置的字符和前一个字符进行位置交换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+R</td>
<td style="text-align:center">以交互方式搜索命令历史记录</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+PGUP/PGDN</td>
<td style="text-align:center">切换到上/下一个标签页</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+↑/↓</td>
<td style="text-align:center">向上/下滚动内容</td>
</tr>
<tr>
<td style="text-align:center">Shift+PageUp/PageDown</td>
<td style="text-align:center">向上/下翻页</td>
</tr>
</tbody>
</table>
<h3 id="Terminator">Terminator</h3>
<p>更方便的终端，区别于默认GNOME终端。</p>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+Shift+E</td>
<td style="text-align:center">垂直分割窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+O</td>
<td style="text-align:center">水平分割窗口</td>
</tr>
<tr>
<td style="text-align:center">F11</td>
<td style="text-align:center">全屏</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+C</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+V</td>
<td style="text-align:center">粘贴</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+W</td>
<td style="text-align:center">关闭（当前）终端</td>
</tr>
<tr>
<td style="text-align:center">Shift+Ctrl+Q</td>
<td style="text-align:center">关闭窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+N/Ctrl+Tab</td>
<td style="text-align:center">在分割的各窗口之间切换</td>
</tr>
<tr>
<td style="text-align:center">Alt+Up/Down/Left/Right</td>
<td style="text-align:center">移动到上/下/左/右边的终端</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+Up/Down/Left/Right</td>
<td style="text-align:center">在水平/垂直分割的终端中将分割条向上/下/左/右移动</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+X</td>
<td style="text-align:center">将分割的某一个窗口放大至全屏使用</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+Z</td>
<td style="text-align:center">从放大至全屏的某一窗口回到多窗格界面</td>
</tr>
</tbody>
</table>
<blockquote>
<p>选中即复制，鼠标中键粘贴。对于单词，双击即可选中，三击选中一行。</p>
</blockquote>
<h2 id="tips">tips</h2>
<h3 id="终端程序静默运行">终端程序静默运行</h3>
<ul>
<li>在 Linux（以及类 Unix 系统）的终端（shell）中，命令末尾加上 <code>&amp;</code>，表示<strong>让该命令在“后台”运行</strong>。这就是常说的“后台进程”（background process）。</li>
<li><strong>默认情况下</strong>，你在终端执行一个命令，shell 会等待该命令执行完毕，期间终端会被该进程“占用”。</li>
<li><strong>加上 <code>&amp;</code></strong>，shell 会让这个命令在后台运行，立即把控制权还给你，你可以继续在终端输入其它命令，甚至直接关闭终端窗口（如果进程没有依赖终端，则不会被终端关闭而退出）。</li>
<li><strong>图形界面（GUI）程序</strong>（如 VS Code）通常加 <code>&amp;</code> 就足够，不会因为关闭终端而退出（但在某些特殊终端或远程 SSH 下还是建议用 <code>nohup</code>）。</li>
</ul>
<h3 id="Shell脚本一次性启动多个程序（对应多个终端）">Shell脚本一次性启动多个程序（对应多个终端）</h3>
<p>经常开发ros环境的应该知道，当节点太多难以控制的时候，不如写个脚本直接启动多个节点（对应多个终端）。</p>
<p>先介绍一下<code>gnome-terminal</code>命令的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">gnome-terminal  <span class="hljs-comment"># 打开一个新的终端</span><br><span class="hljs-comment"># 参数</span><br><span class="hljs-comment"># 基本用法</span><br>--maximize  <span class="hljs-comment"># 打开后自动最大化</span><br>--full-screen  <span class="hljs-comment"># 打开后全屏</span><br>--window  <span class="hljs-comment"># 打开多个终端，多个标签页</span><br>	gnome-terminal --window --window  <span class="hljs-comment">#打开两个</span><br>	gnome-terminal --window --tab --window --tab --tab  <span class="hljs-comment">#打开两个，第一个两个tab，第二个3个tab</span><br>-t  <span class="hljs-comment"># 设置终端的标题。注意，有些版本不支持。</span><br><span class="hljs-comment"># 设置打开的位置和大小（宽度x高度+左侧偏移量+上方偏移量）</span><br>gnome-terminal --geometry=80x25+10+10<br><br><span class="hljs-comment"># 启动后自动执行命令</span><br>-e  <span class="hljs-comment"># 可以出现多次。如果在所有--window前面，表示对所有window和tab起作用，如果在--window或者--tab后面，表示只针对这个tab执行，要注意-e后面只能有一个参数，也就是说如果有空格，需要用引号。</span><br>-x  <span class="hljs-comment"># 只能出现一次，在-x后面的所有内容，均认为是要执行的命令，所以可以出现空格，这些命令是针对所有tab都执行的。</span><br>gnome-terminal -x bash -c <span class="hljs-string">&quot;ls&quot;</span><br>gnome-terminal -e <span class="hljs-string">&#x27;bash -c &quot;ls&quot;&#x27;</span><br><span class="hljs-comment"># 注，运行时会警告：</span><br><span class="hljs-comment"># 参数“-x”弃用并可能在 gnome-terminal 的后续版本中移除。</span><br><span class="hljs-comment"># 参数“-e”弃用并可能在 gnome-terminal 的后续版本中移除</span><br><span class="hljs-comment"># 使用“-- ”以结束选项并将要执行的命令行追加至其后。</span><br><span class="hljs-comment"># 所以，现在可以直接用“--”来替换掉“-x”和“-e”了。</span><br><br><span class="hljs-comment"># 执行完成后保持终端不自动关闭。</span><br><span class="hljs-comment"># 1. 最后加上exec bash的命令，并用分号跟前面的命令隔开。</span><br>gnome-terminal -x bash -c <span class="hljs-string">&quot;ls; exec bash&quot;</span><br>gnome-terminal -e <span class="hljs-string">&#x27;bash -c &quot;ls; exec bash&quot;&#x27;</span><br><span class="hljs-comment"># 2. 修改terminal的配置，在terminal点右键，选择Profiles-&gt;Profile Preferences，然后找到Title and Command，里面有一项When command exits，后面选择为Hold the terminal open，然后就可以了。</span><br><span class="hljs-comment"># 3. 把结果重定向给less，这样less执行完之前，是不会退出的。</span><br>gnome-terminal -x <span class="hljs-built_in">ls</span>|less<br></code></pre></td></tr></table></figure>
<p>了解上面后我们可以创建属于自己的脚本了：</p>
<ol>
<li>
<p>在ROS工作空间（例如，<code>catkin_ws</code>文件夹）下创建一个脚本文件，例如<code>runROS.sh</code>。</p>
</li>
<li>
<p>写入内容，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>gnome-terminal --window -- bash -c <span class="hljs-string">&quot;source ./devel/setup.bash &amp;&amp; roslaunch PACKAGE_NAME *.launch; exec bash&quot;</span><br><span class="hljs-built_in">sleep</span> 3s<br>gnome-terminal --window -- bash -c <span class="hljs-string">&quot;source ./devel/setup.bash &amp;&amp; rosrun PACKAGE_NAME NODE_NAME *.yaml; exec bash&quot;</span><br><span class="hljs-built_in">sleep</span> 3s<br>gnome-terminal --window -- bash -c <span class="hljs-string">&quot;rosbag play /yourfolder/*.bag; exec bash&quot;</span><br></code></pre></td></tr></table></figure>
<p>需要什么节点按照这个模块添加即可。</p>
<p>对于使用Terminator终端和zsh shell，修改文件内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/zsh</span><br>terminator -e <span class="hljs-string">&quot;zsh -c &#x27;source ./devel/setup.zsh &amp;&amp; roslaunch PACKAGE_NAME *.launch; exec zsh&#x27;&quot;</span><br><span class="hljs-built_in">sleep</span> 3s<br>terminator -e <span class="hljs-string">&quot;zsh -c &#x27;source ./devel/setup.zsh &amp;&amp; rosrun PACKAGE_NAME NODE_NAME *.yaml; exec zsh&#x27;&quot;</span><br><span class="hljs-built_in">sleep</span> 3s<br>terminator -e <span class="hljs-string">&quot;zsh -c &#x27;source ./devel/setup.zsh &amp;&amp; rosbag play /yourfolder/*.bag; exec zsh&#x27;&quot;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里播放<code>rosbag</code>前面需要加上<code>source ./devel/setup.zsh</code>，否则会报错<code>zsh:1: command not found: rosbag</code>。</p>
</blockquote>
<blockquote>
<p>如果<code>exec zsh</code>命令未能在命令运行完成后保持终端窗口打开，可以尝试修改terminal的配置，在terminal点右键，选择Profiles-&gt;Profile Preferences，然后找到Title and Command，里面有一项When command exits，后面选择为Hold the terminal open。</p>
</blockquote>
<blockquote>
<p>因为<code>roscore</code>和<code>roslanuch</code>打开ROS节点后不会自行关闭，需要使用快捷键<code>Ctrl+C</code>手动关闭，所以不会运行到<code>exec zsh</code>这一步。</p>
<p>而且，使用快捷键<code>Ctrl+C</code>手动关闭ROS节点后，终端会直接退出，也就是关闭窗口（这个BUG？反而能自动关闭终端窗口，减少了自己的操作？）。</p>
<p>如果<code>Ctrl+C</code>后不想关闭终端，可以在terminal点右键，选择Profiles-&gt;Profile Preferences，然后找到Title and Command，里面有一项When command exits，后面选择为Hold the terminal open。不过即使这样，当前终端也不再能输入命令，只能使用Terminator的功能水平分割/数值分割另起一个终端。</p>
</blockquote>
<blockquote>
<p>当我手动 Ctrl + C 关闭 gnome-terminal + zsh，时，程序完全退出后才会关闭终端窗口。但当我使用 <a href="#xdotool">xdotool</a> 模拟 Ctrl + C时，就算保持窗口常开，程序也会直接退出（留下一个临时文件），而不像手动时会处理完临时文件后再退出。相反，当我使用 gnome-terminal + bash 时，程序总会完全退出并保持窗口。这在有些情况下反而是可取的。</p>
</blockquote>
</li>
<li>
<p>给脚本文件授予权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> 755 runROS.sh<br></code></pre></td></tr></table></figure>
<p><code>chmod 755</code> 设置用户的权限为：</p>
<ol>
<li>文件所有者可读可写可执行。</li>
<li>与文件所有者同属一个用户组的其他用户可读可执行。</li>
<li>其它用户组可读可执行。</li>
</ol>
</li>
<li>
<p>运行脚本文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> catkin_ws<br>./runROS.sh<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>完成。</p>
</li>
</ol>
<p><a href="https://zeyulong.com/posts/c4541b88/#%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8">进阶使用</a></p>
<h3 id="Shell脚本在语句报错后终止运行">Shell脚本在语句报错后终止运行</h3>
<h4 id="set命令">set命令</h4>
<ul>
<li>
<p><strong><code>set -e</code></strong>：启用错误检测，命令返回非零状态时脚本立即退出。</p>
<blockquote>
<p><code>set -e</code>命令的作用域是全局的，也就是说，一旦执行了<code>set -e</code>命令，它会影响整个脚本中所有后续的命令，无论它是在<code>if</code>语句内还是外面。</p>
</blockquote>
</li>
<li>
<p><strong><code>set +e</code></strong>：禁用错误检测，命令返回非零状态时脚本继续执行。</p>
</li>
<li>
<p><strong><code>set -x</code></strong>：启用调试模式，执行命令前打印命令。</p>
</li>
<li>
<p><strong><code>set +x</code></strong>：禁用调试模式，执行命令前不打印命令。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用错误检测</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一个成功的命令</span><br>echo &quot;This command will succeed.&quot;<br>ls /<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">禁用错误检测，以便处理单个命令的错误</span><br>set +e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一个可能失败的命令</span><br>echo &quot;This command may fail.&quot;<br>ls /nonexistent_directory<br>status=$?<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">手动检查命令的退出状态</span><br>if [ $status -ne 0 ]; then<br>  echo &quot;The command failed with status $status. Handling the error...&quot;<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">在此处添加错误处理逻辑</span><br>else<br>  echo &quot;The command succeeded.&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重新启用错误检测</span><br>set -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">另一个成功的命令</span><br>echo &quot;This command will also succeed.&quot;<br>ls /<br><br>echo &quot;Script completed.&quot;<br></code></pre></td></tr></table></figure>
<h4 id="继续执行">继续执行</h4>
<p><code>shell</code>脚本在语句报错后默认仍会继续向下执行，解决方法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 增加语句</span><br><span class="hljs-built_in">set</span> -e<br><span class="hljs-comment"># 或，二选一即可</span><br><span class="hljs-built_in">set</span> -o errexit<br><span class="hljs-comment"># 或，使用逻辑与</span><br>python3 main.py &amp;&amp;<br>python3 do.py<br></code></pre></td></tr></table></figure>
<h3 id="Shell脚本自动输入密码">Shell脚本自动输入密码</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;password&quot;</span> | sudo -S <span class="hljs-built_in">command</span>  <span class="hljs-comment"># 可见加上-S参数sudo才会从标准输入中读取密码，不加-S参数以上命令将起不到作用</span><br></code></pre></td></tr></table></figure>
<h3 id="Shell脚本按下Ctrl-C后仍可以执行功能">Shell脚本按下Ctrl+C后仍可以执行功能</h3>
<p><a target="_blank" rel="noopener" href="https://www.freedium.cfd/https://lovethepenguin.com/how-to-handle-ctrl-c-in-bash-scripts-d7085e7d3d47">How to handle ctrl+c in bash scripts</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">cleanup</span></span>()&#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CTRL+C pressed, clean up things before exiting...&quot;</span><br>  <span class="hljs-built_in">rm</span> -rf test.tmp 2&gt;/dev/null<br>  <span class="hljs-built_in">exit</span> 1<br>&#125;<br><br><span class="hljs-comment"># Trap the SIGINT signal (Ctrl+C)</span><br><span class="hljs-built_in">trap</span> cleanup SIGINT<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>  <span class="hljs-built_in">touch</span> test.tmp<br>  <span class="hljs-built_in">sleep</span> 1<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running...&quot;</span><br>  <span class="hljs-built_in">rm</span> -f test.tmp<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>trap</code>命令允许捕获信号（Ctrl+C是SIGINT信号）并在捕获后执行命令，<code>trap</code>语法如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">trap</span> function_command_to_execute SIGNAL<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>为什么你使用 echo 两次？
<ul>
<li>按 ctrl+c 而不输入换行符会弄乱输出。</li>
</ul>
</li>
<li>为什么将 stderr 重定向到<code>/dev/null</code> ？
<ul>
<li><code>/dev/null</code>是一个特殊的设备名称，充当黑洞！你扔在那里的所有东西都会消失！这样，如果我们尝试删除的文件已经被删除，则屏幕上不会显示错误，这可能会无缘无故地让用户感到困惑！</li>
</ul>
</li>
<li>为什么用 <code>exit 1</code> 退出脚本？
<ul>
<li>退出代码非常有用！退出代码 0 表示程序/脚本按预期完成，其他任何值都可能表示因异常方式或错误退出。</li>
<li>这使得故障排除更加容易，而且还允许控制流，我们可以使用 $? 读取脚本或程序的退出状态。这允许 bash 脚本决定如果另一个脚本或程序异常退出时该怎么做。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="为Shell脚本中的文本着色">为Shell脚本中的文本着色</h3>
<p><a target="_blank" rel="noopener" href="https://lovethepenguin.com/linux-how-to-colorize-text-in-bash-scripts-e0426c4348a0">Linux: How to colorize text in bash scripts</a></p>
<h3 id="Shell脚本调试">Shell脚本调试</h3>
<p>在 Shell 脚本中，可以使用 <code>exit</code> 命令来终止脚本的执行。<code>exit</code> 命令会立即停止脚本的运行，并可以选择性地返回一个状态码。</p>
<p>你可以选择性地提供一个状态码，例如 <code>exit 1</code>，表示脚本以错误状态退出。</p>
<h3 id="文件备份与同步">文件备份与同步</h3>
<ol>
<li>
<p><a href="#%E8%BD%AF/%E7%A1%AC%E9%93%BE%E6%8E%A5">创建硬链接</a></p>
</li>
<li>
<p>使用操作系统的文件同步工具</p>
<ul>
<li>
<p>Windows: 使用<code>robocopy</code>命令。</p>
<p>创建一个批处理脚本来定期同步文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">set</span> src_file=<span class="hljs-string">&quot;C:\path\to\your\file.txt&quot;</span><br><span class="hljs-built_in">set</span> dest_file=<span class="hljs-string">&quot;D:\path\to\backup\folder\file.txt&quot;</span><br>:loop<br>robocopy %src_file% %dest_file% /MIR<br><span class="hljs-built_in">timeout</span> /t 60<br>goto loop<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Linux: 使用<a href="#rsync">rsync</a>命令。</p>
<p>创建一个Shell脚本来定期同步文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>src_file=<span class="hljs-string">&quot;/path/to/your/file.txt&quot;</span><br>dest_file=<span class="hljs-string">&quot;/path/to/backup/folder/file.txt&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>    rsync -av --delete <span class="hljs-string">&quot;<span class="hljs-variable">$src_file</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$dest_file</span>&quot;</span><br>    <span class="hljs-built_in">sleep</span> 60<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用文件系统监控工具</p>
<p>你可以使用Python中的watchdog库来监控文件的更改，并在文件发生更改时自动复制到备份文件夹。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install watchdog<br></code></pre></td></tr></table></figure>
<p>编写Python脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">from</span> watchdog.observers <span class="hljs-keyword">import</span> Observer<br><span class="hljs-keyword">from</span> watchdog.events <span class="hljs-keyword">import</span> FileSystemEventHandler<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileChangeHandler</span>(<span class="hljs-title class_ inherited__">FileSystemEventHandler</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, src_path, dest_path</span>):<br>        self.src_path = src_path<br>        self.dest_path = dest_path<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_modified</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.src_path == self.src_path:<br>            shutil.copy2(self.src_path, self.dest_path)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;File <span class="hljs-subst">&#123;self.src_path&#125;</span> has been backed up to <span class="hljs-subst">&#123;self.dest_path&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">monitor_file</span>(<span class="hljs-params">src_path, dest_path</span>):<br>    event_handler = FileChangeHandler(src_path, dest_path)<br>    observer = Observer()<br>    observer.schedule(event_handler, path=src_path, recursive=<span class="hljs-literal">False</span>)<br>    observer.start()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        observer.stop()<br>    observer.join()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    src_file = <span class="hljs-string">&quot;path/to/your/file.txt&quot;</span><br>    dest_file = <span class="hljs-string">&quot;path/to/backup/folder/file.txt&quot;</span><br>    monitor_file(src_file, dest_file)<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>使用云存储服务。你可以使用云存储服务（如Dropbox、Google Drive、OneDrive等）来自动同步文件。将文件放在云存储的同步文件夹中，云存储服务会自动同步文件到云端和其他设备。</p>
</li>
</ol>
<h3 id="在bash终端窗口查看上一个命令的开始位置">在bash终端窗口查看上一个命令的开始位置</h3>
<p>在 Linux 的终端中，没有直接的命令可以一键跳转到上一个命令的开始位置，因为终端主要是一个输出流，并没有内置的“标记位置”或“跳转到输出开头”的功能。然而，可以通过以下方法间接实现类似的功能：</p>
<h4 id="使用终端滚动功能">使用终端滚动功能</h4>
<p>大多数终端（例如 Ubuntu 的默认终端 <code>gnome-terminal</code>）支持滚动查看之前的输出：</p>
<ul>
<li>快捷键：
<ul>
<li><strong>Ctrl + Shift + ↑/↓</strong>：向上或向下滚动内容。</li>
<li><strong>Shift + PageUp/PageDown</strong>：快速向上或向下翻页。</li>
</ul>
</li>
<li>鼠标滚轮：
<ul>
<li>使用鼠标滚轮向上滚动查看之前的输出内容。</li>
</ul>
</li>
</ul>
<h4 id="提前清屏">提前清屏</h4>
<p>在运行耗时较长、输出较多的命令之前，手动清屏以标记起始位置。</p>
<ul>
<li>在终端窗口执行<code>clear</code>命令会清空屏幕，运行命令后，输出内容从清空后的顶部开始。</li>
<li>当你想回到命令开头时，只需向上滚动到屏幕顶部。</li>
</ul>
<blockquote>
<p>“Ctrl+L”类似于<code>clear</code>命令，但并不会真正删除屏幕后面的内容，只是将光标移到屏幕顶部，并清空可见区域。</p>
</blockquote>
<h4 id="标记开始位置">标记开始位置</h4>
<ol>
<li>
<p>在运行命令之前，打印一个明显的分隔符，方便在输出中快速找到起点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;========== Start ==========&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>打开终端的搜索功能“Ctrl+Shift+F”并输入关键字（例如 <code>========== Start ==========</code>），快速定位到命令开头。</p>
</li>
<li>
<p>完成。</p>
</li>
</ol>
<h4 id="将输出重定向到文件">将输出重定向到文件</h4>
<p>如果你执行的命令输出非常多，可以提前将其输出保存到文件中，方便后续查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">your_command &gt; output.txt<br></code></pre></td></tr></table></figure>
<h1 id="Windows">Windows</h1>
<h2 id="快捷键-2">快捷键</h2>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
<th style="text-align:center"><a href="#%E8%AE%BE%E7%BD%AE/%E9%87%8D%E6%98%A0%E5%B0%84%E5%BF%AB%E6%8D%B7%E9%94%AE">自定义</a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><mark>虚拟桌面</mark></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Win+Ctrl+D</td>
<td style="text-align:center">创建新的虚拟桌面，并切换到它</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Win+Ctrl+&lt;-/-&gt;</td>
<td style="text-align:center">切换桌面</td>
<td style="text-align:center">Ctrl+Alt+↑/↓</td>
</tr>
<tr>
<td style="text-align:center">Win+Tab（或Alt+Tab且按住Alt）</td>
<td style="text-align:center">打开任务视图</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><mark>窗口</mark></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Ctrl+N</td>
<td style="text-align:center">新建当前窗口</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+N</td>
<td style="text-align:center">新建文件夹</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Win+D</td>
<td style="text-align:center">将所有打开的窗口最小化，并转到桌面，再次按下即刻恢复所有内容</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Win+&lt;-/-&gt;</td>
<td style="text-align:center">可以自动将应用窗口完全贴靠到屏幕两侧</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Win+ ↑</td>
<td style="text-align:center">可以将应用窗口最大化</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Win+ ↓</td>
<td style="text-align:center">可以将应用窗口最小化。若是当前窗口处于最大化状态，则按住 Win 键不放，连续按两下 ↓ 键即可将窗口最小化。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Win+V</td>
<td style="text-align:center">查看剪切板历史</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>其它一些可参考<a href="#Linux">Linux快捷键</a>。</p>
</blockquote>
<p>其它：</p>
<ol>
<li>将窗口移动到另一个虚拟桌面（不幸的是，Windows不包括直接用于在虚拟桌面之间移动窗口的键盘快捷键）：Win+Tab打开任务视图后，使用鼠标拖动应用窗口到另一个虚拟桌面。</li>
<li>Windows 10 系统 Win+&lt;-/-&gt; 分屏失效处理方法：控制面板-外观和个性化-轻松使用设置中心-使鼠标更易于使用-取消勾选&quot;将窗口移动到屏幕边缘时不要自动排列窗口&quot;。</li>
<li>设置快捷键：开始菜单-找到“Anaconda Powershell Prompt”-右键：打开文件位置-属性-快捷方式-快捷键：Ctrl+Alt+T。</li>
</ol>
<h2 id="Powershell">Powershell</h2>
<ol>
<li>
<p>Powershell 配置 alias：</p>
<ol>
<li>
<p>打开 Powershell，执行<code>echo $PROFILE</code>命令，确定新建文件的名称和位置。</p>
</li>
<li>
<p>例如：在<code>C:\Users\username\Documents\WindowsPowerShell</code>文件夹下新建<code>Microsoft.PowerShell_profile.ps1</code>文件。</p>
</li>
<li>
<p>按格式输入命令：</p>
<figure class="highlight ps1"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ps1"><span class="hljs-function"><span class="hljs-keyword">function</span> 别名</span> &#123; 需要替代的命令 &#125;<br><span class="hljs-built_in">Set-alias</span> <span class="hljs-string">&#x27;s&#x27;</span> <span class="hljs-string">&#x27;Select-Object&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>以管理员身份打开Powershell 执行命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">Set</span>-ExecutionPolicy RemoteSigned<br># `<span class="hljs-built_in">Set</span>-ExecutionPolicy RemoteSigned` 是一个 Windows PowerShell 命令，用于设置 PowerShell 执行策略。执行策略用于控制是否允许在系统上运行脚本，以及允许哪些来源的脚本运行。<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>重启Powershell。</p>
</li>
</ol>
</li>
<li>
<p>Powershell 执行多条命令：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 在powershell7上已经支持&amp;&amp;操作，如低于该版本请继续往下看<br>(<span class="hljs-built_in">mkdir</span> test) -and (<span class="hljs-built_in">cd</span> test)<br><span class="hljs-built_in">mkdir</span> test;<span class="hljs-built_in">cd</span> test<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>将cmd/powershell中的打印信息输出保存为txt文本文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping www.baidu.com &gt;D:/log.txt<br></code></pre></td></tr></table></figure>
<blockquote>
<p>保存界面上已经执行过的输出内容：点击powershell左上角的下三角形，或直接<code>Ctrl+Shift+P</code>打开命令面板，找到“导出文本”选项，确认保存位置。</p>
</blockquote>
</li>
<li>
<p>打开网址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># starts with default browser and adds to open browser</span><br>Start-Process -FilePath www.google.com<br><span class="hljs-comment"># starts with a specific browser</span><br>Start-Process -FilePath iexplore -ArgumentList www.google.com<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>等等。</p>
</li>
</ol>
<h2 id="命令-2">命令</h2>
<h3 id="复制文件（夹）">复制文件（夹）</h3>
<h4 id="robocopy">robocopy</h4>
<blockquote>
<p>发现如果直接在桌面拖动文件夹进行复制，如果被复制的文件夹内有不正常的文件，整个复制过程就不会被执行。因此，使用命令行执行复制操作。原意是查看是哪个文件破坏了整个复制过程，结果发现可以直接跳过不正常的文件。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">robocopy &lt;<span class="hljs-built_in">source</span>&gt; &lt;destination&gt; [&lt;file&gt;[ ...]] [&lt;options&gt;]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>最好以管理员方式启动终端？以保证复制过程没有文件权限问题。</p>
</blockquote>
<blockquote>
<p>无论文件夹路径最后加不加<code>\</code>，都是将 source 文件夹下的内容复制进 destination 文件夹，而不是复制进 source 文件夹本身。所以要提前新件号 destination 文件夹。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy">官方文档</a></p>
<ul>
<li><code>source</code>: 指定源目录的路径。</li>
<li><code>destination</code>: 指定目标目录的路径。</li>
<li><code>file</code>: 指定要复制的一个或多个文件。支持通配符（ *<strong><strong>或</strong>?</strong> ）。如果不指定此参数，则使用<code>*.*</code>作为默认值。</li>
<li><code>options</code>:指定与<strong>robocopy</strong>命令一起使用的选项，包括<strong>copy</strong> 、 <strong>file</strong> 、 <strong>retry</strong> 、 <strong>logging</strong>和<strong>job</strong>选项。
<ul>
<li><code>/s</code>: 复制子目录。此选项自动排除空目录。</li>
<li><code>/e</code>: 复制子目录。此选项自动包含空目录。</li>
<li><code>/v</code>: 生成详细输出，并显示所有跳过的文件。</li>
<li><code>/mt:&lt;n&gt;</code>: 创建具有n 个线程的多线程副本。 n必须是 1 到 128 之间的整数。n的默认值为 8。为了获得更好的性能，请使用/log选项重定向输出。（慎用，如果遇到复制错误的文件，会卡在那里重复尝试）</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">robocopy <span class="hljs-string">&quot;C:\source_folder&quot;</span> <span class="hljs-string">&quot;D:\destination_folder&quot;</span> /e /v<br></code></pre></td></tr></table></figure>
<h4 id="复制大量小文件">复制大量小文件</h4>
<p>如果你要复制的文件夹内包含大量小文件，可以考虑以下几种方法来提高复制效率：</p>
<ol>
<li>
<p>使用 <a href="#robocopy">robocopy</a> 的多线程选项</p>
<p><code>robocopy</code> 支持多线程复制，可以显著提高复制大量小文件的速度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">robocopy <span class="hljs-string">&quot;C:\source_folder&quot;</span> <span class="hljs-string">&quot;D:\destination_folder&quot;</span> /e /mt:16<br></code></pre></td></tr></table></figure>
<blockquote>
<p>就算不用多线程也很快。</p>
</blockquote>
</li>
<li>
<p>压缩文件夹再复制</p>
<p>将文件夹压缩成一个压缩文件（如 <code>.zip</code>），然后复制压缩文件，最后在目标位置解压。这种方法可以减少文件系统的开销。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Compress-Archive -Path <span class="hljs-string">&quot;C:\source_folder&quot;</span> -DestinationPath <span class="hljs-string">&quot;C:\source_folder.zip&quot;</span>  <span class="hljs-comment"># 使用 PowerShell 压缩文件夹</span><br>copy <span class="hljs-string">&quot;C:\source_folder.zip&quot;</span> <span class="hljs-string">&quot;D:\destination_folder.zip&quot;</span>  <span class="hljs-comment"># 复制压缩文件</span><br>Expand-Archive -Path <span class="hljs-string">&quot;D:\destination_folder.zip&quot;</span> -DestinationPath <span class="hljs-string">&quot;D:\destination_folder&quot;</span>  <span class="hljs-comment"># 使用 PowerShell 解压文件夹</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>使用第三方工具</p>
<p>一些第三方工具如 <code>FastCopy</code> 或 <code>TeraCopy</code> 专门优化了文件复制过程，特别是对于大量小文件的复制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载并安装 FastCopy。</span><br><span class="hljs-comment"># 使用命令行进行复制</span><br>fastcopy.exe /cmd=diff /auto_close <span class="hljs-string">&quot;C:\source_folder&quot;</span> /to=<span class="hljs-string">&quot;D:\destination_folder&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <a href="#rsync">rsync</a>（适用于 Windows Subsystem for Linux）</p>
<p>如果你在 Windows 上安装了 WSL，可以使用 <code>rsync</code>，它在处理大量小文件时表现良好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av --progress /mnt/c/source_folder /mnt/d/destination_folder<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>选择适合你的方法来提高复制大量小文件的效率。</p>
<h3 id="定时关机-2">定时关机</h3>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/de-de/windows-server/administration/windows-commands/shutdown">https://learn.microsoft.com/de-de/windows-server/administration/windows-commands/shutdown</a></p>
<p><a target="_blank" rel="noopener" href="https://www.xitongzhijia.net/xtjc/20220717/246783.html">Win11怎么设置自动关机？Win11使用shut down命令自动关机的方法</a></p>
<p>允许您一次关闭或重新启动一台本地计算机或远程计算机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdown -<span class="hljs-built_in">help</span>  <span class="hljs-comment"># 显示用法</span><br>shutdown -i  <span class="hljs-comment">#  显示图形用户界面(GUI)</span><br>shutdown -s -t 3600  <span class="hljs-comment"># 3600秒后关机</span><br>shutdown -r -t 3600  <span class="hljs-comment"># 3600秒后重启</span><br>shutdown -h  <span class="hljs-comment"># 休眠</span><br>shutdown -a  <span class="hljs-comment"># 取消关机，或者取消重启</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>还可以按 Win+R 快捷键后，在“打开”处输入<code>at 16:00 shutdown -s</code>。(TODO)</p>
</blockquote>
<h2 id="小贴士-3">小贴士</h2>
<h3 id="设置-重映射快捷键">设置/重映射快捷键</h3>
<ol>
<li>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/powertoys">PowerToys</a>的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/powertoys/keyboard-manager">Keyboard Manager</a>工具。</p>
</li>
<li>
<p>添加快捷方式，右键快捷方式-属性-快捷键。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/280725870">参考链接</a></p>
<blockquote>
<p>解决快捷键反应延迟问题：</p>
<ul>
<li>Win10：win+s搜索后台应用-打开后台应用，将“设置“一栏关闭即可。<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44275286/article/details/103988806">参考链接</a></li>
<li>Win11：按下<code>Win</code>键打开开始菜单-所有应用-找到“设置”-右键-更多-应用设置-后台组件权限：从不（默认为电源已优化（推荐））。<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_67168336/article/details/126240582">参考链接</a></li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="下载-2">下载</h3>
<ul>
<li>
<p>Windows系统下也可以运行Linux系统下的<code>*.sh</code>脚本/命令。网上有解决办法，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/johnnyzen/p/17163623.html">例如</a>；或者把shell脚本语言转为Powershell脚本语言。</p>
<ul>
<li>在Powershell下使用<code>Invoke-WebRequest</code>命令下载文件很慢。网上有解决方法，<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1180302">例如</a>。</li>
<li>Powershell下可以使用<code>wget</code>和<code>curl</code>等命令。</li>
</ul>
</li>
<li>
<p>使用<a target="_blank" rel="noopener" href="https://github.com/WindowsAddict/IDM-Activation-Script">IDM</a>、迅雷等下载器。</p>
<ul>
<li>
<p>IDM</p>
<ul>
<li>
<p>优点：（分块）下载速度快（比浏览器默认下载快）；定时下载；（使用通配符）添加批量任务；运行站点抓取；资源嗅探</p>
</li>
<li>
<p>缺点：<a target="_blank" rel="noopener" href="https://github.com/WindowsAddict/IDM-Activation-Script">收费</a>；（大文件）分块下载后合并下载块慢（解决：设置单线程下载；下载的临时文件夹和“保存至”文件夹不要在同一块硬盘上；高配电脑（CPU和SSD））</p>
<blockquote>
<ul>
<li>改成单线程的话，该文件下载速度会变慢。当然，如果你同时下载许多个文件，那么可以这么做，不影响。</li>
<li>同盘剪切一定快于跨盘剪切，但同盘复制一般慢于跨盘复制。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>
<p>迅雷</p>
<ul>
<li>优点：定时下载；下载速度快</li>
<li>缺点：国产软件……想要速度快需要开会员</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="其它-2">其它</h3>
<ol>
<li>
<p>Anaconda Prompt与Anaconda PowerShell Prompt与系统cmd与powershell的区别：</p>
<ul>
<li>cmd
<ul>
<li>优点：无</li>
<li>缺点：Python不行；<code>ls</code>不行</li>
</ul>
</li>
<li>Powershell
<ul>
<li>优点：<code>ls</code>行</li>
<li>缺点：Python不行</li>
</ul>
</li>
<li>Anaconda Prompt
<ul>
<li>优点：Python 行</li>
<li>缺点：<code>ls</code>不行</li>
</ul>
</li>
<li>Anaconda Powershell Prompt【完美】
<ul>
<li>优点：Python 行、<code>ls</code>行</li>
<li>缺点：无</li>
</ul>
</li>
</ul>
</li>
<li>
<p>导入环境变量：搜索“环境变量”——新建。</p>
</li>
<li>
<p>在 Windows PowerShell 终端中打开当前终端所在的文件夹：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">explorer .<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>等等。</p>
</li>
</ol>
<h1 id="其它-3">其它</h1>
<h2 id="3-2-1备份规则">3-2-1备份规则</h2>
<p><a target="_blank" rel="noopener" href="https://www.backblaze.com/blog/the-3-2-1-backup-strategy/">3-2-1 备份策略</a></p>
<p>3-2-1 备份规则是一种简单、有效的策略，可确保数据安全。它建议您将数据的三份副本保存在两个不同的介质上，其中一份副本保存在异地。让我们来分解一下：</p>
<ul>
<li>数据的<strong>三份</strong>副本：您的三份副本包括原始数据或生产数据以及另外两份副本。</li>
<li>在<strong>两种</strong>不同的介质上：您应该将数据存储在两种不同形式的介质上。这在今天意味着与 2000 年代末有所不同。我稍后会详细讨论这一点。</li>
<li><strong>一份</strong>异地副本：您应该在异地远程位置保存一份数据副本，最好距离其他两份副本几英里远。</li>
</ul>
<p>如果您想保护您的个人信息、照片、工作文件或其他重要数据，3-2-1 备份策略是您的最佳选择。它可以帮助您避免出现容易受到人为错误、<a target="_blank" rel="noopener" href="https://www.backblaze.com/blog/backblaze-drive-stats-for-q1-2024/">硬盘驱动器崩溃</a>、盗窃、自然灾害或<a target="_blank" rel="noopener" href="https://www.backblaze.com/blog/category/cloud-storage/ransomware/">勒索软件</a>影响的单点故障。``</p>
<h2 id="文件（夹）命名">文件（夹）命名</h2>
<h3 id="命名规范">命名规范</h3>
<p>为了确保日常使用的方便与系统兼容性，个人电脑上的文件夹和文件命名应遵循一定的规范。以下是一些通用的指导原则和最佳实践：</p>
<ol>
<li><strong>简洁明了</strong>：命名应简单且直接表达文件内容或文件夹用途，避免过长或含糊不清的名称。</li>
<li><strong>避免使用特殊字符</strong>：一般来说，文件名中不应包含如下字符：<code>\/:*?&quot;&lt;&gt;|</code>。这些特殊字符在多数操作系统中有特定用途，可能导致错误或不被识别。</li>
<li><strong>使用合适的文件扩展名</strong>：文件扩展名反映了文件的类型，如 <code>.txt</code> 表示文本文件，<code>.jpg</code> 表示JPEG图像文件。正确的扩展名有助于操作系统正确识别和打开文件。</li>
<li><strong>利用日期和版本控制</strong>：在文件名中包含日期（如 <code>2023-03-15</code>）可以帮助管理文件版本。对于频繁更新的文档，可能还需要添加版本号（如 <code>v1.0</code>、<code>v2.0</code>）。</li>
<li><strong>避免空格</strong>：虽然大多数现代操作系统可以很好地处理文件名中的空格，但在某些情况下（如命令行操作或网络传输）可能会引起问题。可以使用下划线（_）或破折号（-）来代替空格。</li>
<li><strong>区分大小写</strong>：虽然Windows系统的文件名不区分大小写，但Linux和macOS区分大小写。为了兼容性，最好在命名时注意大小写的一致性。</li>
<li><strong>组织性和易读性</strong>：对于包含多个文件的文件夹，可以采用有组织的命名体系，如按功能、日期或项目分类。</li>
<li><strong>国际化和本地化</strong>：如果你的文件可能会被不同语言的用户访问，避免使用特定语言的字符，尽量使用英文和国际通用的符号。</li>
</ol>
<p>遵循这些基本原则可以帮助提升文件管理的效率和降低因命名不当引起的问题。如果有特定的组织或项目命名规则，也应优先遵守这些专业指导标准。</p>
<h3 id="命名方法">命名方法</h3>
<blockquote>
<p>整词用驼峰或下划线<code>_</code>命名，整词间用<code>-</code>分隔。</p>
</blockquote>
<p>在个人电脑上命名文件夹和文件时，虽然没有像编程语言那样严格的命名规范，但仍可以借鉴一些编程中的命名方法来组织文件，使其更加有序和易于管理。以下是一些常见的命名方法，以及如何将它们应用于文件和文件夹的命名：</p>
<ol>
<li><strong>小驼峰式命名法 (lowerCamelCase)</strong>:
<ul>
<li><strong>应用</strong>: 适用于文件名，尤其是在需要保持名称简洁且连贯的情况下。</li>
<li><strong>示例</strong>: <code>personalBudget.xlsx</code>, <code>summerVacationPhotos.jpg</code></li>
</ul>
</li>
<li><strong>大驼峰式命名法 (UpperCamelCase)</strong>:
<ul>
<li><strong>应用</strong>: 适合用于较重要的文件和项目文件夹，特别是在编程项目中。</li>
<li><strong>示例</strong>: <code>ProjectReport2023.docx</code>, <code>TaxDocuments2023</code></li>
</ul>
</li>
<li><strong>下划线命名法 (snake_case)</strong>:
<ul>
<li><strong>应用</strong>: 适用于需要强调易读性的情况，也有助于避免在使用某些操作系统和环境时出现问题。</li>
<li><strong>示例</strong>: <code>final_report_2023.pdf</code>, <code>holiday_photos_2022</code></li>
</ul>
</li>
<li><strong>破折号命名法 (kebab-case)</strong>:
<ul>
<li><strong>应用</strong>: 更常见于网页文件和资源，但也可以用于普通文件和文件夹。</li>
<li><strong>示例</strong>: <code>end-of-year-summary-2023.pdf</code>, <code>project-budget-2023.xlsx</code></li>
<li><strong>注意</strong>: 文件系统如Windows和记录系统通常对破折号支持良好，但在某些命令行环境中可能会遇到解释上的问题。</li>
</ul>
</li>
<li><strong>日期前缀命名</strong>:
<ul>
<li><strong>应用</strong>: 对于需要按日期管理的文档或文件，如财务文件或定期报告。</li>
<li><strong>示例</strong>: <code>2023-01-30_MeetingNotes.docx</code>, <code>2023-03-15_Invoice.pdf</code></li>
</ul>
</li>
</ol>
<p>选择哪种命名方法取决于个人偏好、所处的工作环境以及是否需要跨平台交互。例如，如果在一个环境中主要用Python编程，那么使用snake_case可能更自然。而如果是在处理法律或业务文档，使用UpperCamelCase或日期前缀可能更为合适。</p>
<p>无论选择哪种命名方法，重要的是保持一致性，这样可以减少寻找和管理文件的时间，也能使文件系统更加有序。</p>
<h3 id="下划线-与短划线-的对比">下划线_与短划线-的对比</h3>
<table>
<thead>
<tr>
<th><strong>特点</strong></th>
<th><strong>下划线 <code>_</code></strong></th>
<th><strong>短划线 <code>-</code></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>命名风格</strong></td>
<td>常用于变量名、文件名（snake_case）。</td>
<td>常用于文件名、URL（kebab-case）。</td>
</tr>
<tr>
<td><strong>双击选中行为</strong></td>
<td>双击时会选中整个包含下划线的字符串。</td>
<td>双击时只选中单个单词。</td>
</tr>
<tr>
<td><strong>可读性</strong></td>
<td>下划线在代码中更容易识别为分隔符。</td>
<td>短划线在命令行或文件名中更直观。</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>编写代码（变量名、函数名）。</td>
<td>文件名、URL 或配置文件中的键。</td>
</tr>
<tr>
<td><strong>键盘输入</strong></td>
<td>需要按住 Shift 键（<code>Shift + -</code>）。</td>
<td>直接输入，无需按住 Shift 键。</td>
</tr>
<tr>
<td><strong>技术限制</strong></td>
<td>不适用于某些文件系统或 URL（下划线合法但不常用）。</td>
<td>短划线在变量名中不被编译器支持（如 C++）。</td>
</tr>
</tbody>
</table>
<ul>
<li>在很多编程语言中，<code>_</code> 是合法的变量名分隔符，而 <code>-</code> 不是。</li>
<li>在文件系统中，<code>_</code> 通常比 <code>-</code> 更常用，尤其是在需要跨平台（Windows、Linux、macOS）兼容的情况下：
<ul>
<li>某些旧系统可能会错误解析 <code>-</code>。</li>
<li><code>-</code> 在命令行中容易被误解为选项前缀（例如 <code>ls -a</code>）。</li>
</ul>
</li>
<li>短划线更适合文件名和 URL，因为它们在视觉上更易分辨。</li>
<li>如果你更倾向于使用下划线 <code>_</code> 但希望解决双击选中全部字符串问题，可以通过配置编辑器的行为来优化。</li>
</ul>
<h3 id="表示存放未修改的源文件的文件夹">表示存放未修改的源文件的文件夹</h3>
<p>如果一个文件夹存放的是未修改的源文件（例如来自第三方库或外部依赖），常见的命名方式包括：</p>
<ul>
<li><strong><code>vendor/</code></strong>：
<ul>
<li>常见于包含第三方库的代码，例如在前端项目或后端依赖管理中。</li>
<li>例如：<code>vendor/react</code>, <code>vendor/bootstrap</code>.</li>
</ul>
</li>
<li><strong><code>third_party/</code></strong> 或 <strong><code>thirdparty/</code></strong>：
<ul>
<li>表示存放来自第三方的代码或库。</li>
<li>例如：<code>third_party/libpng</code>, <code>third_party/zlib</code>.</li>
</ul>
</li>
<li><strong><code>external/</code></strong>：
<ul>
<li>用于存放外部依赖项，强调这些文件是外部的而且未修改。</li>
<li>例如：<code>external/protobuf</code>, <code>external/sqlite</code>.</li>
</ul>
</li>
<li><strong><code>original/</code></strong> 或 <strong><code>src/</code></strong>：
<ul>
<li>如果这些源文件是项目的一部分，但未经过修改，<code>original/</code> 表示它们是原始版本。</li>
<li>例如：<code>original/images</code>, <code>src/original_code</code>。</li>
</ul>
</li>
</ul>
<h3 id="表示额外的、杂的、不属于其他文件夹分类的文件">表示额外的、杂的、不属于其他文件夹分类的文件</h3>
<p>在软件开发中，如果需要一个文件夹存放一些 <strong>额外的、杂的、不属于其他文件夹分类的文件</strong>，通常会使用以下命名方式：</p>
<ul>
<li>
<p><strong><code>misc/</code></strong>（最常见）</p>
<ul>
<li>
<p><strong>含义</strong>：表示 &quot;miscellaneous&quot;（杂项、其他）。</p>
</li>
<li>
<p><strong>用途</strong>：存储那些不容易归类到其他文件夹的文件。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>miscellaneous/</code></strong></p>
<ul>
<li><strong>含义</strong>：<code>miscellaneous</code> 是 &quot;misc&quot; 的完整拼写形式。</li>
<li><strong>用途</strong>：与 <code>misc/</code> 类似，但更正式。</li>
</ul>
</li>
<li>
<p><strong><code>other/</code></strong></p>
<ul>
<li><strong>含义</strong>：表示 &quot;other files&quot;（其他文件）。</li>
<li><strong>用途</strong>：存储那些不属于其他分类的文件。</li>
</ul>
</li>
<li>
<p><strong><code>extra/</code></strong></p>
<ul>
<li><strong>含义</strong>：表示 &quot;extra files&quot;（额外文件）。</li>
<li><strong>用途</strong>：表示一些附加文件，通常是非核心文件或附加的内容。</li>
</ul>
</li>
<li>
<p><strong><code>temp/</code></strong></p>
<ul>
<li><strong>含义</strong>：表示临时文件（temporary）。</li>
<li><strong>用途</strong>：如果这些杂项文件是临时性的或供短期使用，可以存放在 <code>temp/</code> 文件夹。</li>
</ul>
</li>
</ul>
<h3 id="表示一个文件是另一个文件的备份">表示一个文件是另一个文件的备份</h3>
<p>备份文件的命名方式通常遵循几个规则，以清晰地表示其来源和目的：</p>
<ul>
<li><strong>使用后缀 <code>.bak</code></strong>（常见于备份文件）：
<ul>
<li>例如：<code>config.json.bak</code></li>
<li>表示 <code>config.json</code> 文件的备份版本。</li>
</ul>
</li>
<li><strong>在文件名中添加 <code>backup</code></strong>：
<ul>
<li>例如：<code>config_backup.json</code></li>
<li>清楚地表明这是一个备份文件。</li>
</ul>
</li>
<li><strong>添加时间戳</strong>：
<ul>
<li>例如：<code>config_20250423.json</code> 或 <code>config_backup_20250423.json</code></li>
<li>通过时间戳标记备份的创建时间，方便管理多个备份。</li>
</ul>
</li>
<li><strong>命名模板：<code>original_filename.bak</code>, <code>original_filename.timestamp</code></strong>：
<ul>
<li>例如：
<ul>
<li><code>data.csv.bak</code></li>
<li><code>data_20250423.csv</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="中文文本中夹用英文时，是否要留有空格">中文文本中夹用英文时，是否要留有空格</h2>
<blockquote>
<p>推荐留空，方便整词选择。如果不留空，选择时可能会选择夹杂中英文的整行而不是单个英文单词。</p>
</blockquote>
<p>中文文本中夹用英文时，应根据所选用的中英文字体、字符间距以及排版的视觉效果决定英文词句与中文文字之间是否留有空格间距。如留空格，应保证体例的统一。——中华人民共和国新闻出版行业标准CY/T 154—2017号《中文出版物夹用英文的编辑规范》第8.1节</p>
<ul>
<li>但同时我更鼓励各类排版引擎自动在用户没有显式输入空格字符的情况下，也在中英文词汇间产生适当的间距。现在有一些已经做到了，比如 iOS 系统、微信、Microsoft 办公软件等。</li>
</ul>
<h2 id="浏览器搜索操作符">浏览器搜索操作符</h2>
<p>可以直接用此网址，不需要记命令，它自动组装为命令：</p>
<ul>
<li>
<p>百度高级搜索：<a target="_blank" rel="noopener" href="https://www.baidu.com/gaoji/advanced.html">https://www.baidu.com/gaoji/advanced.html</a></p>
</li>
<li>
<p>谷歌高级搜索：<a target="_blank" rel="noopener" href="https://www.google.com.hk/advanced_search">https://www.google.com.hk/advanced_search</a></p>
</li>
<li>
<p>GitHub高级搜索：<a target="_blank" rel="noopener" href="https://github.com/search/advanced">https://github.com/search/advanced</a></p>
</li>
</ul>
<p>语法：</p>
<ul>
<li>整词搜索：双引号。示例：&quot;关键词&quot;</li>
<li>逻辑与：空格。示例：关键词1 关键词2</li>
<li>逻辑或：空格OR空格。示例：关键词1 OR 关键词2</li>
<li>逻辑非：空格-（减号前面必须是空格，减号后面没有空格，要紧跟着需要排除的词）。示例：关键词 -排除词</li>
<li>模糊搜索：*（通配符，匹配任意词或短语）。示例：<code>国家* 匹夫*</code></li>
<li>指定网站：关键词 site:网站地址。注意：“site:”后面跟的站点域名，不要带“http://”。site:和站点名之间，不要带空格。示例： 编程教程 site:blog.csdn.net</li>
<li>排除指定网站：关键词 -site:网站地址。示例：编程教程 -site:blog.csdn.net</li>
</ul>
<h2 id="中英文版本的简称">中英文版本的简称</h2>
<p>当描述一个文件是中文版本时，通常使用的语言代码有几种不同的形式，主要取决于具体的语境和标准。最常见的是“zh”，这是ISO 639-1标准下的代码，用于表示中文。然而，如果需要指明具体是简体中文还是繁体中文，人们可能会使用“zh-CN”（中国大陆使用的简体中文）和“zh-TW”（台湾地区使用的繁体中文）。这些是基于IETF语言标签（由ISO 639和ISO 3166国家代码组合而成），广泛用于网站和软件本地化中。</p>
<p>对于英文版本，通常使用的语言代码为“en”，这同样遵循ISO 639-1标准。如需进一步区分不同地区的英语，例如美国英语和英国英语，则分别使用“en-US”和“en-GB”。</p>
<p>这些缩写在多语言处理、软件本地化、网页语言标签等方面非常重要。选择正确的代码有助于正确设置语言环境，确保内容正确呈现给目标用户群体。如果有更具体的用途，如编程、文件标签或其他，请提供详细信息，以便提供更精确的建议。</p>
<h2 id="命令行参数设计">命令行参数设计</h2>
<p>在命令行参数设计中，使用一个短划线（<code>-v</code>）还是两个短划线（<code>--v</code>）取决于参数的用途和常见的命令行约定。以下是它们的区别和使用场景：</p>
<ul>
<li>单短划线（<code>-v</code>）
<ul>
<li>使用一个短划线通常表示<strong>短选项</strong>。</li>
<li>短选项通常是单个字母，简洁易用，例如：
<ul>
<li><code>-v</code>（verbose，启用详细输出）</li>
<li><code>-h</code>（help，显示帮助信息）</li>
</ul>
</li>
<li>短选项<mark>可以组合</mark>在一起。例如，<code>-abc</code>相当于<code>-a -b -c</code>。</li>
<li>短选项适合经常使用的参数，因为打字很快。</li>
</ul>
</li>
<li>双短划线（<code>--v</code> 或 <code>--verbose</code>）
<ul>
<li>使用两个短划线表示<strong>长选项</strong>。</li>
<li>长选项通常是一个完整的单词或短语，便于理解，例如：
<ul>
<li><code>--verbose</code>（启用详细输出）</li>
<li><code>--help</code>（显示帮助信息）</li>
</ul>
</li>
<li>长选项通常不允许组合，必须单独列出。</li>
<li>长选项更<mark>适合不常用的参数，或者需要更清晰语义的场景</mark>。</li>
</ul>
</li>
<li>最佳实践是同时支持短选项和长选项，为用户提供灵活性。</li>
</ul>
<h2 id="截取屏幕的固定区域">截取屏幕的固定区域</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageGrab  <span class="hljs-comment"># pip install pillow</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">capture_fixed_area</span>(<span class="hljs-params">left, top, right, bottom, output_file=<span class="hljs-string">&quot;screenshot.png&quot;</span></span>):<br>    <span class="hljs-comment"># 定义截图区域（left, top, right, bottom）</span><br>    bbox = (left, top, right, bottom)<br><br>    <span class="hljs-comment"># 截图</span><br>    screenshot = ImageGrab.grab(bbox)<br><br>    <span class="hljs-comment"># 保存截图到文件</span><br>    screenshot.save(output_file)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;截图已保存到: <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 设置命令行参数解析</span><br>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;Capture a specific area of the screen.&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Left coordinate of the rectangle.&quot;</span>)<br>    parser.add_argument(<span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Top coordinate of the rectangle.&quot;</span>)  <br>    parser.add_argument(<span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Right coordinate of the rectangle.&quot;</span>)  <br>    parser.add_argument(<span class="hljs-string">&quot;bottom&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Bottom coordinate of the rectangle.&quot;</span>)<br>    parser.add_argument(<br>        <span class="hljs-string">&quot;--output_file&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">&quot;screenshot.png&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Path to save the screenshot (default: screenshot.png).&quot;</span>  <br>    )<br><br>    <span class="hljs-comment"># 解析命令行参数</span><br>    args = parser.parse_args()<br><br>    <span class="hljs-comment"># 调用截图函数</span><br>    capture_fixed_area(args.left, args.top, args.right, args.bottom, args.output_file)<br></code></pre></td></tr></table></figure>
<p>使用以下命令运行脚本，并传递截图的区域坐标和输出文件路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python capture_fixed_area_with_cli.py 700 300 1200 1180 --output_file fixed_area_screenshot.png<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%BA%93/" class="category-chain-item">软件工具库</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>系统常用命令及快捷键</div>
      <div>http://zeyulong.com/posts/a8aab215/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>龙泽雨</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/c3a050a5/" title="ESVIO编译运行调试记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ESVIO编译运行调试记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/df5eb46/" title="Anaconda、CUDA、cuDNN和PyTorch包的安装">
                        <span class="hidden-mobile">Anaconda、CUDA、cuDNN和PyTorch包的安装</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://www.zeyulong.cn/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10,"reaction":true,"locale":{"placeholder":"花径不曾缘客扫，蓬门今始为君开。"}},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/custom/RunTime/RunTime.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/custom/LabelPage/LabelPage.js"></script>
<script src="/custom/LoadingBar/pace.min.js"></script>
<script src="/custom/ReadingProgress/ReadingProgress.js"></script>
<script src="/custom/typing-effect/typing-effect.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  <canvas
    class="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script type="text/javascript" src="/custom/fireworks/anime.min.js"></script> 
<script type="text/javascript" src="/custom/fireworks/fireworks.js"></script>

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
